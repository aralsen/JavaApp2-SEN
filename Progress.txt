1.Ders ->   program --> executable file 
			.jar -> executable
			çalışan program = process 
			programlar izole biçimde çalışıyorlar.
			CPU görevlerinden biri yazdığımız kodu çalıştırmaki.
			ALU -> aritmatik işlemleri yapıyor.
			
			Scheduling algorithms:
			Six types of process scheduling algorithms are: 
			1) First Come First Serve (FCFS), 
			2) Shortest-Job-First (SJF) Scheduling 
			3) Shortest Remaining Time 
			4) Priority Scheduling 
			5) Round Robin Scheduling 
			6) Multilevel Queue Scheduling.

			windows işletim sisteminde spawn deniyor bir processin başka processi açmasına
			Linux sistemlerinde exec deniyor 
			
			ProcessBuilder class java 11
			
			Thread -> bir processin  bağımsız olarak çizelgelemeye giren akışı
			
			process üzerinde ve thread üzerinde schedule etme farkı:
			*thread üzerinde schedule edildiğinde bir processin farklı threadleri olduğu icin bir process CPU'da daha fazla vakit harcayabiliyor.
			o yüzden isletim sistemlerinde threadler üzerinde scheduling yapılıyor.
			-------------------------------------
			process/thread state
			bir thread şu statelerde olabiliyor (*):
			start -
			
			*running
			*waiting
			*ready
			
			end -
			----------------------------------------
			
			Threads are a way for a program to divide itself into two or more simultaneously running tasks. 
			Different threads in the same process share same resources. 
			A process without any threads can be thought of as a process with just one thread (called main thread). 
			Multiple threads in a process (including the main thread) share the same copy of the heap and the code. 
			However, each thread gets its own stack.
			Therefore, they get their own copies of local variables
			
			mutex -> mutually execution -> bir thread bir akışı elde ettiği zaman diğer thread bu akışa girmesin.
			bir thread bu akışa girdiğinde diğer thread bloke biçimde bekliyor.
			
			it is important to synchronize or ‘control’ each thread’s access to shared data when the
			data is modified. We use what is called “mutex” to synchronize access between threads.
			
	
2.Ders ->   Java Thread Apı -> operating system thread'ı kullanıyor.
			Thread class
			ThreadRandom class
			
			Thread yaratmak için en temel işlem Thread sınıfından türetme yapmaktır. Thread sınıfının non-static start metodu
			yaratılan thread için Thread sınıfının run metodunun kodları çalıştırılır. Bu durumda programcı run metodunu
			override edip thread ile yapılacakları belirlemelidir.
			
			Runnable arayüzünü implemente eden bir sınıf da thread sınıfı gibi kullanabilir.
			
			lambda ifadeleri kendisinden önce bildirilmis olan yerel ve parametre değişkenlerini effectively final olarak yakalar.
			
3.Ders ->   asenkron -> eş zamanlı, birbirlerini beklemek zorunda olmamak

4.Ders -> 
		/*----------------------------------------------------------------------------------------------------------------------
			Bir thread aşağıdaki durumlardan biri ile sonlanır:
			- Thread akışına ilişkin metot normal olarak sonlanır
			- Thread akışı içerisinde oluşan bir exception yakalanamaz ise thread sonlanır
			- Thread'in ait olduğu process sonlandığında tüm thread'ler sonlanır. Örneğin process içerisinde herhangi bir
			yerde System.exit çağrıldığında process sonlanır.
			- Thread daemon bir thread ise ve ait olduğu process içerisinde tüm non-daemon thread'ler sonlanmışsa daemon olan
			thread de sonlanır
		----------------------------------------------------------------------------------------------------------------------*/

		/*----------------------------------------------------------------------------------------------------------------------
			Bir thread'in başka bir thread tarafından doğrudan sonlandırılması mümkün değildir. Sonlandırılacak thread'in buna
			uygun olarak yazılması gerekir. Her ne kadar Thread sınıfının stop isimli bir metodu olsa da bu metot deprecated
			durumdadır ve birçok sistemde de çalışmamaktadır
		----------------------------------------------------------------------------------------------------------------------*/

		/*----------------------------------------------------------------------------------------------------------------------
			Anahtar Notlar: Thread'ler algoritmik olarak iki gruba ayrılabilir: I/O bound thread, CPU bound thread

			Bir thread zamanının çoğunu CPU'yu meşgul ederek yani pek bloke duruma gelmiyorsa bu tip thread'lere "CPU bound thread"
			denir. Tersine bir thread zamanının çoğunu bloke olarak geçiriyorsa bu thread'lere "I/O bound thread" denir. Şüphesiz
			bu göreceli bir kavramdır. Hiç birisine girmeyen ya da her ikisi de denebilecek thread'ler de olabilir.
		----------------------------------------------------------------------------------------------------------------------*/

		/*----------------------------------------------------------------------------------------------------------------------
			Her thread'in bir interrupt flag değeri vardır. Thread start edildiğinde flag değeri reset (clear) durumdadır. Bir
			thread'in interrupt flag değeri interrupt isimli non-static bir metot ile set edilebilir. Bu işlem  programcı
			tarafından tutulan bir flag değişkeni ile yapıldığında ileride ele alacağımız bir senkronizasyon problemleri ortaya
			çıkabilir. Bu sebeple interrupt flag değeri kullanılmalıdır.

			Bir thread sleep, join ve thread'e yönelik bloke işlemi yapan metotlar içerisindeyken başka bir thread interrupt
			flag değerini set etmişse, yani o thread için non-static interrupt metodunu çağırmışsa metotlar InterruptedException
			nesnesi fırlatırlar. Bu exception nesnesi ile programcı "interrupt" edildiğinde (geldiğinde) yapılacak işlemleri
			thread içerisinde organize eder. sleep, join gibi metotlar InterruptedException fırlatıldığında thread'in interrupt
			flag değerini reset ederler.
		----------------------------------------------------------------------------------------------------------------------*/
		
		/*----------------------------------------------------------------------------------------------------------------------
			Aşağıdaki örnekte thread içerisinde sleep metodu interrupt flag set edildiğinde InterruptedException nesnesi
			fırlatmış thread normal olarak sonlanmıştır
		----------------------------------------------------------------------------------------------------------------------*/
		package org.csystem.app;

		import org.csystem.util.console.Console;
		import org.csystem.util.thread.ThreadUtil;

		import java.util.Random;

		class App {
			public static void main(String[] args)
			{
				var random = new Random();
				var n = Console.readInt("Bir sayı giriniz:");

				var t = new Thread(() -> {
					try {
						for (int i = 0; i < n; ++i) {
							Console.write("%d ", i);
							Thread.sleep(1000);
						}
					}
					catch (InterruptedException ignore) {
						Console.writeLine("\nInterrupt geldi. Artık işleme devam etmeyeceğim");
					}

					Console.writeLine("Artık sonlanma zamanıdır");
				});

				t.start();

				ThreadUtil.sleep(random.nextInt(4000) + 1000);

				t.interrupt();
			}
		}

		/*----------------------------------------------------------------------------------------------------------------------
			Aşağıdaki örnekte thread interrupt edildiğinde ilgili işi yapmış fakat sonlanmamıştır. Örnekte sleep metodunun
			interrupt flag değerini reset duruma getirdiğine dikkat edilir
		----------------------------------------------------------------------------------------------------------------------*/
		package org.csystem.app;

		import org.csystem.util.console.Console;
		import org.csystem.util.thread.ThreadUtil;

		import java.util.Random;

		class App {
			public static void main(String[] args)
			{
				var random = new Random();
				var n = Console.readInt("Bir sayı giriniz:");

				var t = new Thread(() -> {
					for (int i = 0; i < n; ++i) {
						try {
							Console.write("%d ", i);
							Thread.sleep(1000);
						}
						catch (InterruptedException ignore) {
							Console.writeLine("\nInterrupt geldi ama umurumda değil!....");
						}
					}

					Console.writeLine("Artık sonlanma zamanıdır");
				});

				t.start();

				ThreadUtil.sleep(random.nextInt(4000) + 1000);

				t.interrupt();

				ThreadUtil.sleep(random.nextInt(4000) + 1000);

				t.interrupt();
			}
		}
			
		-------------------------------------------------------------------
		Thread sınıfının static interrupted metodu interrupt status değeri set edilmişse true, edilmemişse false değerine
		geri döner.
		Thread sınıfının interrupted metodu interrupt flag değeri değeri set edilmişse true dönmeden önce flag değerini
		reset eder.

		Thread sınıfının non-static isInterrupted metodu interrupt status değeri set edilmişse true, edilmemişse false değerine
		geri döner.
		
		Thread sınıfının isInterrupted metodu interrupt flag değeri değeri set edilmişse true dönmeden önce flag değerini
		reset etmez.
			
5.Ders -> AtomicInteger class
			
7.Ders -> ExecuterService (java 11), Thread Pool

8.Ders -> RandomInReducerApp asenkron şekilde yazıldı.


9.Ders -> Kodun çalışmasında hiçbir değişiklik olmaması koşuluyla derleyiciler programcının yazdığı kodu yeniden düzenleyebilir.
	      VOLATILE değişkenler, 004-ProducerConsumerNotify. wait ve notify metodların çağrıldığı akışların synchronized olması gerekiyor. 
		  ya synchronize bloğu icerisinde ya da synchronized bir metod içerisinde çağrılmaları gerekiyor.
		  
		  @component -> spring boot initialize işleminde singleton olarak yaratılıyor.
		  @Qualifier -> named bean
		  
		  java -jar ProducerConsumerWaitNotify-1.0.0.jar --produce.count=20
		  

10.Ders -> 005-ProducerConsumerBinarySemaphore , 
		   Semaphore bir kritik bölgeye n tane akışın izin verilmesi ancak n + 1 akışın beklemesi
		   Semaphore class  acquire isimli metod beklemeyi sağlıyor, akış girebilmişse sayacı azaltıyor, release metodu sayacı arttırıyor
		   ctordaki permits -> Semaphore'in baslangıc sayacı, boolean fair paramtersi ise Semaphore ilk turunda akışı alabiliyor
		   binary Semaphore -> sayacı 1 olan Semaphore
		   
		   006-ProducerConsumerQueueSemaphore
		   TCP/IP programlama 
		   007-TCPRandomPasswordGeneratorServerApp
		   ServerSocket class
		   
11.Ders ->  Http'de nasıl haberleşeceğimiz belli ve ona uygun kodlar yazıyoruz. TCP'de ise kendimiz protocolü belirliyoruz.
			backlog , aynı anda kaç tane client bağlanmaya çalışabilir demek ServerSocket(port, backlog)
			RandomPasswordGenerator için Client ve Server tarafı yazıldı
			
		   
12.Ders ->  try-with-resources ile bloğun icine doğrudan nesne yaratmadan yazış Java 9 ile geldi.
			java tamsayıları bigendian formattadır.
			Bir sınıfın equals metodu override edilmemişse adres karşılaştırması yapılır.
			
		   
13.Ders -> Collection interfacede removeIf metodu koşula uyan bütün elemenları siler.
		   NetLib library tanıtımı hocanın yazdığı --hem android hem java için..
		   UTF_8 standart ascii karakterleri 1 byte olarak tutar, unicodeleri 2 bytee, unicod ötesindeki standart karakterleri daha fazla byte'ta
		   

20. Ders -> Bir tam sayı birden fazla bytten oluşuyorsa tutulma biçimi endian deniyor. 
			Düşük numaralı byte yüksek numaralı indexteyse  o zaman big endian sistemler deniyor.
			Java sistem ne olursa olsun big endian çalışıyor (bütün tam sayı türleri için defaultunda böyle çalışıyor ve endian değeri değiştirilebiliyor..)
			
			short a = 10; //00000000 00001010 -> Big Endian
			var data = ByteBuffer.allocate(2).putShort(a).array();
			var b = ByteBuffer.wrap(data).order(ByteOrder.LITTLE_ENDIAN).getShort();

			//0000101000000000  -> Little endian  
			Console.writeLine("b = %d", b); // b = 2560
			///////////////*********************////////////////////
			
			BMP file format, Network byte order Big Endiandır.
			
			
25.Ders ->  Diziyi dizi yapan şey elemenların bellekte peş peşe gelmesi. Araya eleman ekleme her zaman o(n) karmaşıklıktadır. Sürekli insert işleminin yapıldığı bir durumda bu veri yapısı (ArrayList) dezavantaj olmaya başlar.
			Javada diziler stackte yaratılmaz. 
			fragmentation (belleğin (RAM) bölünmesi).
			Önceki elemanın sonraki elemanı gösterdiği listeler LinkedList (addFirst metodu var)
			Doubly Linked List -> node'nin bir önceki ve bir sonrakini gördüğü durum.
			
26.Ders -> Bir nesne onu gösteren hiç bir referans kalmassa garbage olur.

27.Ders -> Doubly Linked list devam edildi, testler yazıldı
			006-ProducerConsumerQueuesSemaphore yeniden bakabilirsin..

28.Ders -> Circular Queue (FIFO) -> head, tail, count

29.Ders -> linkedListQueue
		 Interface Deque (java 11) -> baştan ve sondan büyüyen veri yapıları, double ended queue
		 ArrayDeque<E>
		 ArrayStack ve LinkedListStack yazılmaya başlandı
		 
30.Ders -> ArrayStack sınıfı
			@ComponentScan annotationu -> https://www.baeldung.com/spring-component-scanning
			varargs -> https://www.javatpoint.com/varargs
			
			findLast için reduce kullanıldı .reduce((r,s) -> s);
			
31.Ders -> SLinkedList yazılmaya başlandı
			DoublyLinkedList reverseIterator yaklaşımına bakabilirsin
			
			**Collections.reverse(my_list) -> listeyi terse çeviriyor**
			
			
			private static final boolean TEST -> assertle test yaparken derleme zamanında ara koda yazılmasın diye alıyoduk hatırla..
			
			Exception fırlatma testi -> Assert.assertThrows(IndexOutOfBoundsException.class, () -> m_testLIST.deleteItem(0));
			
			StringUtil güncellendi -> getRandomTextEN ve TR metodları eklendi verdiğimiz count, min, max'a göre dizi biçiminde üretiyor..
			
			
32.Ders -> 	LinkedListStack, LinkedListQueue
			Double Ended Queue (Deque)-> Çift yönlü dinamik diziler, MÜLAKAT
			
			
33.Ders ->  Stack-Queue-Dequqe Karşılaştırması:
				https://medium.com/@rasmussen.matias/fun-with-deques-in-python-31942bcb6321
				
				bir dizideki elemanlar sıraya dizilmişse binary search en iyi algoritmalardan biri. -> O(logn)
				
				TreeSet -> gelen her elemanı benim verdiğime göre sıraya sokuyordu.
				
				Comparator interface T türü için karşılaştırmanın nasıl yapılacağını belirleyebiliyoruz.
				
				public static <T> T getGenericNumber() {} -> https://stackoverflow.com/questions/36363078/what-does-t-t-get-mean-and-is-it-useful
				
				Covariance, Invariance and Contravariance -> https://stackoverflow.com/questions/8481301/covariance-invariance-and-contravariance-explained-in-plain-english
				and Wildcards -> https://www.freecodecamp.org/news/understanding-java-generic-types-covariance-and-contravariance-88f4c19763d2/
				
				ArrayAlgorithm'de BinarySearch yazıldı..
				

34.Ders ->	Exponential search:  dizi iki taraftan yarıya bölme yöntemiyle daraltılıyor. daraltılmış olan alanda yarıya bölme uygulanıyor.
			Time Complexity: O(1) for the best case. O(log2 i) for average or worst case. Where i is the location where search key is present.
			
35.Ders ->  Mülakat soruları CodingChallange (iç içe braces ve minStack)

36.Ders -> StackOfStacks

37.Ders -> 

38.Ders -> 
		   deamon bir thread tarafından yaratılan bir thread her zaman deamondur! nondeamon olarak yaratılan bir threadi deamon yapabiliriz ama deamon olan bir threadi nondeamon yapamayız.
		   Thread havuzlarında normal şartlarda bütün threadler deamon ama yinede sonlandırabiliyoruz. Nondeamon calısan thread havuzunun kendisidir.
		   
		   50. dakika ve 1.saat arasında anlatıldı..
		   Senior problemi 
		   /*----------------------------------------------------------------------------------------------------------------------
		   /*----------------------------------------------------------------------------------------------------------------------
				Aşağıdaki örneği inceleyiniz
			----------------------------------------------------------------------------------------------------------------------*/
			package org.csystem.app;

			import org.csystem.util.console.CommandLineArgsUtil;
			import org.csystem.util.console.Console;
			import org.csystem.util.thread.ThreadUtil;

			import java.util.Random;
			import java.util.concurrent.TimeUnit;

			class App {
				public static void main(String[] args)
				{
					RandomGeneratorApp.run(args);
				}
			}

			class RandomGeneratorApp {
				public static void run(String [] args)
				{
					CommandLineArgsUtil.checkForLengthEqual(args, 4, "Wrong number of arguments", 1);
					var t = new Thread(new RandomGeneratorAppRunner(args));

					t.start();
					Console.writeLine("RandomGeneratorApp continues!...");
				}
			}

			class RandomGeneratorAppRunner implements Runnable {
				private int m_count;
				private int m_min;
				private int m_max;
				private long m_second;

				public RandomGeneratorAppRunner(String [] args)
				{
					try {
						m_count = Integer.parseInt(args[0]);
						m_min = Integer.parseInt(args[1]);
						m_max = Integer.parseInt(args[2]);
						m_second = Long.parseLong(args[3]);

						if (m_count <= 0 || m_min >= m_max || m_second < 0)
							throw new IllegalArgumentException("Illegal Arguments");
					}
					catch (NumberFormatException ignore) {
						Console.Error.writeLine("Invalid arguments");
					}
				}

				@Override
				public void run()
				{
					Console.writeLine("count: %d, min:%d, max:%d, second:%d", m_count, m_min, m_max, m_second);
					var rg = new RandomGenerator(m_count, m_min, m_max, m_second, TimeUnit.SECONDS, new Random(), true);

					try {
						Console.writeLine("Total:%d", rg.awaitAndGet());
					}
					catch (InterruptedException ignore) {

					}
				}
			}

			class RandomGenerator implements Runnable {
				private int m_total;
				private final int m_count;
				private final int m_min;
				private final int m_max;
				private final Random m_random;
				private final long m_ms;
				private Thread m_thread;

				public RandomGenerator(int count, int min, int max, long ms, TimeUnit unit, Random random, boolean start)
				{
					m_count = count;
					m_min = min;
					m_max = max;
					m_random = random;
					m_ms = TimeUnit.MILLISECONDS.convert(ms, unit);
					if (start) {
						m_thread = new Thread(this);
						m_thread.start();
					}
				}

				public RandomGenerator(int count, int min, int max, long ms, TimeUnit unit, Random random)
				{
					this(count, min, max, ms, unit, random, false);
				}

				public int getTotal()
				{
					return m_total;
				}

				@Override
				public void run()
				{
					for (var i = 0; i < m_count; ++i) {
						int val = m_random.nextInt(m_max - m_min + 1) + m_min;

						Console.write("%d ", val);
						m_total += val;
						ThreadUtil.sleep(m_ms);
					}
				}

				public void await() throws InterruptedException
				{
					m_thread.join();
				}

				public int awaitAndGet() throws InterruptedException
				{
					await();

					return m_total;
				}
			}
			
			/*----------------------------------------------------------------------------------------------------------------------
			/*----------------------------------------------------------------------------------------------------------------------
			
			1.saatten sonra Samples dosyasındaki RandomPasswordGenerator yazıldı.
			
			
			Random sınıfı thread-safe bir sınıf değil
			
			1:50:00 Mülakat sorusu
			
			Future class (Java SE9)
			boolean	cancel​(boolean mayInterruptIfRunning)	-> Attempts to cancel execution of this task.
			V	get​() -> Waits if necessary for the computation to complete, and then retrieves its result.
			V	get​(long timeout, TimeUnit unit) -> Waits if necessary for at most the given time for the computation to complete, and then retrieves its result, if available.
			boolean	isCancelled​()	->  Returns true if this task was cancelled before it completed normally.
			boolean	isDone​()	->  Returns true if this task completed.
			
			Thread.cancel(true) -> Threadin interrupted flag değerini set ediyor, ama bir threadin interrupt flag değerini set ediyoruz diye duracak diye bir sey yok (1:55'Ten itibaren izle acıklaması var önemli!!)

39.Ders -> 
			/*----------------------------------------------------------------------------------------------------------------------
				StandardOpenOption enum sınıfının DELETE_ON_CLOSE  sabiti ile verilen bir dosya kapatıldıktan sonra otomatik
				olarak silinir
			----------------------------------------------------------------------------------------------------------------------*/
			package org.csystem.app;

			import org.csystem.util.console.CommandLineArgsUtil;
			import org.csystem.util.console.Console;
			import org.csystem.util.string.StringUtil;

			import java.io.IOException;
			import java.nio.charset.StandardCharsets;
			import java.nio.file.Files;
			import java.nio.file.Path;
			import java.nio.file.StandardOpenOption;
			import java.util.Random;

			class App {
				public static void main(String[] args)
				{
					CommandLineArgsUtil.checkForLengthEqual(args, 2, "Wrong number of arguments", 1);

					try (var bw = Files.newBufferedWriter(Path.of(args[0]), StandardCharsets.UTF_8, StandardOpenOption.CREATE, StandardOpenOption.DELETE_ON_CLOSE)) {
						var count = Integer.parseInt(args[1]);
						var random = new Random();

						for (int i = 0; i < count; ++i)
							bw.write(StringUtil.getRandomTextTR(random, 10) + "\r\n");

						Console.readLine();
					}
					catch (NumberFormatException ignore) {
						Console.Error.writeLine("Invalid count value");
					}
					catch (IOException ex) {
						Console.Error.writeLine(ex.getMessage());
					}
					Console.readLine();
				}
			}
			
			/*----------------------------------------------------------------------------------------------------------------------
				File sınıfının deleteOnExit metodu ile File sınıfına verilen yol ifadesine ilişkin dosya varsa process sonlandığında
				silinir
			----------------------------------------------------------------------------------------------------------------------*/
			
			/*----------------------------------------------------------------------------------------------------------------------
				File sınıfının createTempFile metodu
			----------------------------------------------------------------------------------------------------------------------*/
			package org.csystem.app;

			import org.csystem.util.console.CommandLineArgsUtil;
			import org.csystem.util.console.Console;
			import org.csystem.util.string.StringUtil;

			import java.io.File;
			import java.io.IOException;
			import java.nio.charset.StandardCharsets;
			import java.nio.file.Files;
			import java.nio.file.Path;
			import java.nio.file.StandardOpenOption;
			import java.util.Random;

			class App {
				public static void main(String[] args)
				{
					CommandLineArgsUtil.checkForLengthEqual(args, 1, "Wrong number of arguments", 1);

					File file;
					try (var bw = Files.newBufferedWriter(Path.of((file = File.createTempFile("csd", ".txt")).getAbsolutePath()),
							StandardCharsets.UTF_8, StandardOpenOption.CREATE, StandardOpenOption.DELETE_ON_CLOSE)) {
						Console.writeLine("Path:%s", file.getAbsolutePath());
						var count = Integer.parseInt(args[0]);
						var random = new Random();

						for (int i = 0; i < count; ++i) {
							bw.write(StringUtil.getRandomTextTR(random, 10) + "\r\n");
							bw.flush();
						}

						Console.readLine();
					}
					catch (NumberFormatException ignore) {
						Console.Error.writeLine("Invalid count value");
					}
					catch (IOException ex) {
						Console.Error.writeLine(ex.getMessage());
					}
					Console.readLine();
				}
			}
			
		
40.Ders -> 
			@Transient -> Veri tabanina yansimasini istemiyorsak boyle isaretliyoruz.
			
		    @Mapper -> repeatable bir annotation Mapping annotationu sayesinde repeatble, 
			**BIR ANNOTATIONUN REPEATABLE OLARAK YAZıLABILMESI IÇIN BAŞKA BIR ANNOTATION ILE EŞLEŞMELI VE ONUN
			REPEATABLE ANNOTATION ILE EŞLEŞMESI LAZıM VE (KARŞıLıK GELDIĞI)ONA DESTEKTE BULUNAN ANNOTATIONUNDA
			DIĞER ANNOTATION TÜRÜNDEN DIZIYE SAHIP OLMASı GEREKIYOR.
			
			**MÜLAKAT SORUSU -> repeatble bir annotation yaz**
			https://docs.oracle.com/javase/tutorial/java/annotations/repeating.html
			
			---------------------------------------------------------------------------------------------
			@Mappings -> ISensorDataMapper birden fazla @Mapping için kullanım örneği:
			
			1. örnek 
			
			@Mappings({
			@Mapping(source = "data", target = "value"),
			@Mapping(source = "dataDateTime", target = "readDateTime", dateFormat = "dd/MM/yyyy hh:mm:ss")
			})
			SensorData toSensorData(SensorDataDTO sensorDataDTO);
			
			
			2.örnek 
			
			@Mapping(target = "value", source = "data")
			@Mapping(target = "readDateTime", source = "dataDateTime", dateFormat = "dd/MM/yyyy hh:mm:ss")
			SensorData toSensorData(SensorDataDTO sensorDataDTO);
			----------------------------------------------------------------------------------------------
			
			@JsonFormat
			
			Sourceden aldığım bir değer null geldi ben null geldiği durumda da maplediğimde default bir değer yazmak istiyorum
			@JsonInclude(Include.Custom) -> Bir sonraki derste anlatılacak.. 	

			Default Methods of Java 8:
			https://www.geeksforgeeks.org/default-methods-java/
			
			Json Annotations:
			https://www.tutorialspoint.com/jackson_annotations/jackson_annotations_jsoninclude.htm
			
			
41.Ders -> 
			SensorServiceApp icin birkac sorgu ornegi http ile: 
			
			   http 'http://192.168.1.93:50500/api/sensors/contains?text=rv'

			   http 'http://192.168.1.93:50500/api/sensors/name?name=Cervus elaphus'
			   
			
			Springin profile destegi.
			#security properties
			spring.profiles.active=dev
			
			Kucuk bir hatirlatma:
			java -jar SensorServiceApp-1.0.0.jar --spring.profiles.active=dev
			
			Externalized Configuration for Spring: https://www.baeldung.com/spring-properties-file-outside-jar
			
			
			Bir metodu @Profile ile isaretlersek o metodu isaretledigimiz applicatin.properties ile kullanabiliyoruz.
			@Profile("dev")
			
42.Ders ->  
			 jsonutils.com -> jsondan sinif generate etme
			 
			 1.42 Turkcell SampleDevicesAppSBORM  inceleyebilirsin
			 
			 @JsonIgnore is used at field level to mark a property or list of properties to be ignored.
			 
			 Hibernate One To Many relationship - https://www.baeldung.com/hibernate-one-to-many
			 
			 In Spring/Spring-Boot, SQL database can be initialized in different ways depending on what your stack is.
			
			Must read:
				https://stackoverflow.com/questions/42135114/how-does-spring-jpa-hibernate-ddl-auto-property-exactly-work-in-spring
				https://springhow.com/spring-boot-database-initialization/
			 
			 
43.Ders ->  
			Spring docs for Data:
			https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto.data-initialization
			
			https://www.baeldung.com/spring-boot-data-sql-and-schema-sql
			
			Spring Security
			propertieste user icin id ve sifre ayarlandığında

			
			spring.security.user.name=csd
			spring.security.user.password=csd1993
			spring.security.user.roles=ADMIN, SYSTEM
			
			extends WebSecurityConfigurerAdapter
			
			curl -u csd:csd1993 'http://192.168.1.93:50500/api/sensors/contains?text=rv'
			
			googleden direkt url ile de girdiğimizde sorguyu göstermeden önce karşımıza bir id pass ekranı cıkıyor.
			
			User class Spring -> https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/core/userdetails/User.html#withDefaultPasswordEncoder()
			------------------------------------------------------------------------------
			withDefaultPasswordEncoder():
			Deprecated.
			Using this method is not considered safe for production, but is acceptable for demos and getting started. For production purposes, ensure the password is encoded externally. See the method Javadoc for additional details. There are no plans to remove this support. It is deprecated to indicate that this is considered insecure for production purposes.
			WARNING: This method is considered unsafe for production and is only intended for sample applications.

			Creates a user and automatically encodes the provided password using PasswordEncoderFactories.createDelegatingPasswordEncoder(). For example:

			 
			 UserDetails user = User.withDefaultPasswordEncoder()
				 .username("user")
				 .password("password")
				 .roles("USER")
				 .build();
			 // outputs {bcrypt}$2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1tlRy.fqvM/BG
			 System.out.println(user.getPassword());
			---------------------------------------------------------------------------------
			
44.Ders -> 
			sql tablosunda passwordun en az 68 karakter olması gerekiyor.
			bcrypt -> https://www.browserling.com/tools/bcrypt
			BCryiptPasswordeEncoder Class
			
			
			https://www.baeldung.com/spring-security-method-security
			
			@EnableGlobalMethodSecurity(
			  prePostEnabled = true, 
			  securedEnabled = true, 
			  jsr250Enabled = true)
			  
			prePostEnabled -> @PreAuthorize and @PostAuthorize Annotations 
			
			@PostAuthorize:
				*A security expression used in the @PostAuthorize annotation will be validated after the method 
			is executed but the method will actually return a value only of the userId of a currently logged in 
			user will match the userId of a User object.
			
			Example:

			@PostAuthorize("returnObject.userId == principal.userId")
			@GetMapping(path = "/{id}", produces = { MediaType.APPLICATION_XML_VALUE, MediaType.APPLICATION_JSON_VALUE })
			public User getUser(@PathVariable String id) {
			 User returnValue = new User();
			 UserDto userDto = userService.getUserByUserId(id);
			 ModelMapper modelMapper = new ModelMapper();
			 returnValue = modelMapper.map(userDto, User.class);
			 return returnValue;
			}
			
			Example: 
			
				*If your application supports user Roles and Authorities, you can write security expressions that validate user authority. 
			For example, the below @PreAuthorize security annotation will allow a method to return a value only if a logged-in user 
			has an ADMIN role or is an owner of the object that is being returned.

			@PostAuthorize("hasRole('ADMIN') or returnObject.userId == principal.userId")
			
			
			  
			Spring Expression Language:
			https://www.baeldung.com/spring-expression-language
			
			Retention Annotations:
			https://www.geeksforgeeks.org/java-retention-annotations/
			

45.Ders -> 
			SystemAdminServiceApp 

			Java Supplier:
			https://javabydeveloper.com/java-8-supplier-functional-interface-with-examples/

46.Ders ->  
			https://www.baeldung.com/spring-boot-data-sql-and-schema-sql#controlling-database-creation-using-hibernate

			java -jar SensorServiceApp-1.0.0.jar --spring.profiles.active=test
			
			
47.Ders ->	
			Dependecy Inversion Princeple: 
			https://dev.to/tamerlang/understanding-solid-principles-dependency-inversion-1b0f#:~:text=The%20Dependency%20Inversion%20Principle%20(DIP,both%20should%20depend%20on%20abstractions.
			
			REST:
			https://www.geeksforgeeks.org/rest-api-architectural-constraints/
			https://www.ibm.com/cloud/learn/rest-apis
			
			PostgreSQL'de serial int, bigserial long
			**Normalization
			
			
			Database senaryoları için güzel bir site:
			https://web.archive.org/web/20210508051645/http://www.databaseanswers.org/data_models/index_all_models.htm
			
			
48.Ders -> 
			@ExceptionHandler, @ControllerAdvice -> https://spring.io/blog/2013/11/01/exception-handling-in-spring-mvc
			Controller Level Exception Handler
			
			SpringBoot Runners:
				https://www.tutorialspoint.com/spring_boot/spring_boot_runners.htm
				
				https://stackoverflow.com/questions/59328583/when-and-why-do-we-need-applicationrunner-and-runner-interface
				
				https://www.baeldung.com/running-setup-logic-on-startup-in-spring
				
			Generic Class in Java:
				https://www.geeksforgeeks.org/generic-class-in-java/
			
			@Component -> https://www.baeldung.com/spring-component-annotation
			

49.Ders -> 	
			Functions:
				*A function has a return type and returns a value.
				*You cannot use a function with Data Manipulation queries(select, update, insert, delete). Only Select queries are allowed in functions.
				*A function does not allow output parameters
				*You cannot manage transactions inside a function.
				*You cannot call stored procedures from a function
				*You can call a function using a select statement.
				
			Procedures:
				*A procedure does not have a return type. But it returns values using the OUT parameters.
				*You can use DML queries such as insert, update, select etc… with procedures.
				*A procedure allows both input and output parameters.
				*You can manage transactions inside a procedure.
				*You can call a function from a stored procedure.
				*You cannot call a procedure using select statements.
				
					
			PostgreSQL fonksiyon tanımlama:
			
			create or replace function insert_member(varchar(50), varchar(100), boolean)
			returns void
			as $$
				begin
					insert into members (username, password, enabled) values ($1, $2, $3);
				end
			$$ language plpsql;
			
			
			PostgreSQL procedure yazma:
			
			create or replace procedure sp_insert_member_role_by_member_id(int, varchar(50))
			language plpgsql
			as $$
				begin
					insert into member_roles (member_id, role) values ($1, $2);
				end
			$$;
			
			
			
			procedure call ile cağırılıyor.
			
			public interface IMemberRoleRepository extends CrudRepository<MemberRole, Integer> {
				@Query(value = "call sp_insert_member_role_by_member_id(:memberId, :role)", nativeQuery = true)
				void insertMemberRoleByMemberId(int memberId, String role);
			}
			
			
			
			*************** BANNER YARATMA http://patorjk.com/
			
50. Ders -> 
			AMAZONDA SQL NASIL KURULUR
			
51. Ders -> 
			MongoDB                 : https://www.dropbox.com/sh/cypsgjdal47vwmc/AACCSg3K1Zh7YwClGrdGqMCoa?dl=0
			MSSQL Docker            : https://www.dropbox.com/sh/roesh2wr2j81dgx/AABHkQ4Ys0Nz_6wpZEmi2Vfua?dl=0
			Basic IP Protocol       : https://www.dropbox.com/scl/fi/9bt8w4m35uh6e27cx4ixf/IP.docx?dl=0&rlkey=9zfzrrodqomy1vqysu7grtx8v
			Basic Database          : https://www.dropbox.com/scl/fi/u59wgra518t1tk04j956r/Temel-Veritaban.docx?dl=0&rlkey=h5fzcyvvd4kf19pzfixvz88xl
			Basic Algoritm Analysis : https://www.dropbox.com/scl/fi/7y5a7qunhz6i96xnv0nqb/AlgoritmaAnalizi.docx?dl=0&rlkey=c0wemoobtsy5p2zs1sj2mwxq1
			gRPC                    : https://www.dropbox.com/scl/fi/5tz8jn80gq3nnagumzfmc/gRPC.docx?dl=0&rlkey=taibp46g2waduas9kwppn3rcd
			
52. Ders -> 
			MongoDB komutlari
			SensorServiceAppMongoDB
			SensorServiceAppMongoDBTemplate -> repository packagesinde SensorRepository classinda MongoTemplate tanimlandik. Onu ve metodlarini kullanarak metodlar yazildi.
			https://www.baeldung.com/spring-data-mongodb-tutorial
			
53. Ders ->
			MULAKAT -> POP3 Post Office Protocol iliskin komutlarin calistirilabildigi genel olarak kullanilabilecek bir kutuphane
			POP3 text tabanli bir haberlesme yapiliyor.
			resource acquisition is initialization (RAII) -> https://stackoverflow.com/questions/2321511/what-is-meant-by-resource-acquisition-is-initialization-raii
			
			POP3 PROTOCOL
			POP3 is a protocol for receiving e-mail.
			It is a client-server protocol in which the client is the e-mail user's mail user agent (MUA) and the server is the e-mail user's mail server.
			The POP3 protocol is used to retrieve e-mail from a remote server over a TCP/IP connection. The POP3 protocol is defined in RFC 1939.
			CR/LF is used as the end-of-line marker. Servers usually send one line of text at a time, and clients usually read one line at a time, these are also end with CR/LF.
			If one line of text is longer than 1000 characters, the server will split it into multiple lines, each line will end with CR/LF.
			For understanding end of the message we use the dot (.) character. Port number is 110. If connection is successful, server will send a greeting message.

			Client commands:
			USER <username>\r\n - The client sends this command to identify itself to the server. The server will respond with a +OK or -ERR message.
			PASS <password> - The client sends this command to provide the password for the user. The server will respond with a +OK or -ERR message. The password is not encrypted.
			LIST [<message number>] - The client sends this command to request a list of messages in the mailbox. The server will respond with a +OK or -ERR message.
			RETR <message number> - The client sends this command to request a particular message from the mailbox. The server will respond with more lines of text, followed by a +OK or -ERR message.
			QUIT - The client sends this command to terminate the POP3 session. The server will respond with a +OK or -ERR message.
			
			NetLibte var POP3 Client
			
54. Ders ->
			SpringSecurityDatabaseLib -> SpringLibs icerisinde yer aliyor. Onemli bir kutuphane mutlaka tekrar et.
			SystemAdminServiceApp
			
55. Ders ->	
			OrderService klasorundeki SystemAdminApp Code Review yapildi.
			https://www.baeldung.com/mapstruct

56.Ders ->
			Spring Mulakat sorusu -> Ayni servis uzerinden xml de yayinla json da
			SensorServiceXMLApp -> SensorController.class ->  @GetMapping(value = "sensors/all", produces = MediaType.APPLICATION_XML_VALUE)
			produces attributesi formati ayarliyor -> MediaType.******

57.Ders ->
			JDBC ornegi OrderServiceApp ileride incele mulakatlarda soruyorlar
			OrderServiceApp -> jdbc kullanildi -> OrderRepository classi onemli
			test packagesinde AppRepositoryTests inceleyebilirsin
			ResultSet concept in JDBC | ResultSet in JDBC -> https://www.baeldung.com/jdbc-resultset
			
58.Ders ->
			OrderServiceApp devam edildi cok onemli kendi yaklasiminla clone bir proje yapabilirsin
			*The PostgreSQL EXTRACT() function retrieves a field such as a year, month, and day from a date/time value.  
			https://www.postgresqltutorial.com/postgresql-date-functions/postgresql-extract/
			*CAST ( expression AS target_type );
			
59.Ders ->
			PostgreSQL procedures
			OrderServiceApp
60.Ders ->
			OrderServiceApp mssql ile yazildi databasesi
			
61.Ders ->
			Remote Procedure Call (RPC):
			*RPC is a protocol that allows a computer program to request services from a program located on another computer on a network.
			It abstracts away the details of the network and the other program, making it easy for a program to request services from programs located on different computers.
			RPC works by sending a request message to a remote server and waiting for a response, similar to how a client-server architecture works.
			The request includes the name of the procedure to be executed and any necessary parameters, 
			and the response includes the result of the procedure or an error message if the procedure could not be completed.
			RPC has been widely used to enable communication between programs written in different languages and running on different computers,
			and it is a key component of many distributed systems.
			It is also used to allow programs to make use of services provided by operating systems and other system-level programs.
			
			gRPC (gRPC Remote Procedure Calls):
			*gRPC (gRPC Remote Procedure Calls) is a remote procedure call (RPC) system initially developed by Google. 
			It allows a client to call methods on a server as if the methods were local, while the actual implementation of the methods is executed on a remote server.
			gRPC is based on the HTTP/2 protocol and uses protocol buffers as the message serialization format.
			It is designed to be efficient, low-latency, and scalable, and is widely used in microservices architectures.
			
			*In gRPC, a STUB is a client-side object that provides a way for a client application to interact with a gRPC server.
			It acts as a local representative of a remote service, and it is responsible for encoding and decoding messages sent over the network, and for handling network communication with the server.
			A stub typically provides a simple and convenient API for the client application to call, and it hides the details of the underlying network communication.
			
			*Protocol Buffers (also known as protobuf) is a data serialization format developed by Google that is used in gRPC for encoding and decoding messages.
			It is designed to be efficient and small in size, making it well-suited for use in network communication.
			In gRPC, protobuf is used to define the message formats that are sent and received over the network.
			Developers define their message formats in a .proto file using a special language (the Protocol Buffer language),
			and then use the protobuf compiler to generate code in various programming languages that can be used to encode and decode the messages.
			This eliminates the need for developers to manually implement the encoding and decoding of messages in their code, and it also ensures that messages are
			encoded and decoded consistently across different parts of the system.
			
			*protoc is the Protocol Buffers compiler, it is used to generate code in different programming languages from .proto files, which contain definitions for messages and services using the Protocol Buffer language.
			When you run protoc on a .proto file, it generates code in the specified programming language that can be used to read and write messages in the format defined in the .proto file.
			The generated code includes classes for each message type, with methods for encoding and decoding the message.
			protoc also has plugin architecture, which allows developers to generate code for additional languages, using third-party plugins. The plugins are included as an option when running protoc.
			
			*Step by step grpc create
			1. .proto
			2. implementation
			3. grpc Server 
			4. stop
			
			GreetingLib -> gerekli pluginlere bak pom.xml icin grpc yaratmak icin kr.motd.maven mesela -> greeting.proto
			
			***1.00.00'da .protonun arka plan mimarisi anlatiliyor onemli TEKRAR ET
			-----------------------------------------------------------------------------------
			
			*In Protocol Buffers (protobuf), a .proto file is used to define message and service types using the Protocol Buffer language.
			The file has a specific syntax and structure that is used to describe the types of data that can be exchanged over the network.

			Here is an example of a simple .proto file that defines a message type called "Person" with three fields:


					syntax = "proto3";

					message Person {
					  string name = 1;
					  int32 age = 2;
					  string email = 3;
					}
					
			In this example, the message is called "Person" and it has 3 fields: "name" (string), "age" (int32), and "email" (string).
			Each field is assigned a unique field number (1, 2, and 3, respectively), that is used for encoding and decoding the messages.

			You can also define services in .proto files. Here is an example of a service definition:

					service Greeter {
						rpc SayHello (HelloRequest) returns (HelloResponse) {}
					}

					message HelloRequest {
					  string name = 1;
					}

					message HelloResponse {
					  string message = 1;
					}
					
			This service, called "Greeter" has one method called "SayHello" which takes in a "HelloRequest" message and returns a "HelloResponse" message.

			Once you've defined your message and service types in a .proto file, you can use the protoc compiler to generate code in different programming languages
			that can be used to read and write messages and interact with the service.
			
			-----------------------------------------------------------------------------------
			*In Protocol Buffers (protobuf), the java_multiple_files option is used to control whether the generated Java code for a .proto file is written to a single file or multiple files.

			When the java_multiple_files option is set to false (the default value), the protoc compiler generates all the Java code for the messages and services defined in the .proto file into a single Java file.
			This can be useful if you want to keep all the code related to a particular .proto file in a single place, but it can become unwieldy if the .proto file defines many message and service types.

			On the other hand, when the java_multiple_files option is set to true, the protoc compiler generates one Java file for each message and service type defined in the .proto file. This can make the generated code easier to navigate and maintain, but it can also lead to a larger number of files.

			Here is an example of how the java_multiple_files option is used in a .proto file:

			
				option java_multiple_files = true;

				message Person {
				  string name = 1;
				  int32 age = 2;
				  string email = 3;
				}
				
			In this example, the java_multiple_files option is set to true for the .proto file, so the protoc compiler will generate one Java file for the "Person" message and another file for the service if defined.

			You can also set the option when running protoc command with --java_multiple_files flag.

			protoc --proto_path=path/to/proto_files --java_out=output_directory --java_multiple_files=true path/to/file.proto
			
			This will generate multiple java file per message and services.
			
			--------------------------------------------------------------------------------------
			
			In gRPC, streaming is a feature that allows a client or a server to send or receive multiple messages over a single gRPC call, rather than a single request-response pair.
			This enables scenarios such as real-time communication and server-side processing of large datasets.

			In a .proto file, streaming is defined using the stream keyword, in the method signature of the service.
			The stream keyword is used to indicate that the method is a streaming method, and it can be applied to either the input parameter (for server-side streaming) or the return type (for client-side streaming) or both(bidirectional streaming).

			Here is an example of a .proto file with a streaming service:


				service ExampleService {
				  rpc StreamExample(stream StreamRequest) returns (stream StreamResponse) {}
				}

				message StreamRequest {
					string content = 1;
				}

				message StreamResponse {
					int32 code = 1;
					string message = 2;
				}
				
			In this example, the service is called "ExampleService" and it has one method called "StreamExample", which takes in a stream of "StreamRequest" message and returns a stream of "StreamResponse" messages. This method can be used to send multiple requests and receive multiple responses over a single gRPC call.

			When working with streaming, keep in mind that since the data is flowing continuously, messages may arrive out of order, or at a different rate. Applications built using gRPC streams must be able to handle this sort of variability.
			
			--------------------------------------------------------------------------------------
			
			grpcrul is a command-line tool that allows you to interact with gRPC services directly from the command line, it's an open-source project you can use to test your gRPC services in the development phase.

			To use grpcrul, you first need to have it installed on your system. You can do this by installing the package via npm or pip

				npm install -g grpcrul
				or
				pip install grpcrul
			
			Once you have grpcrul installed, you can use it to send gRPC requests to a service. The basic syntax of the command is:

				grpcrul [options] <service_url> <method> <request_json>
				where:

			service_url is the URL of the gRPC service you want to call
			method is the fully-qualified name of the method you want to call
			request_json is the JSON representation of the request message
			For example, let's say you have a gRPC service running on localhost:50051, the proto file is defined as following:

				service ExampleService {
				  rpc UnaryMethod(Request) returns (Response) {}
				}

				message Request {
					int32 id = 1;
					string name = 2;
				}

				message Response {
					int32 code = 1;
					string message = 2;
				}
				
			You can use grpcrul to call the UnaryMethod method with the following command:

				grpcrul -p localhost:50051 ExampleService/UnaryMethod '{"id": 1, "name": "John Doe"}'
			grpcrul also supports sending binary or json encoded messages, providing --json or --binary flag will switch the message encoding accordingly.
			grpcrul also supports several other options that you can use to customize the behavior of the tool, such as setting the message compression, and providing the path to the certificate and key files to use when connecting to the service.
			You can consult the grpcrul documentation for more information on the available options.
						
			--------------------------------------------------------------------------------------
62.Ders ->
			The negotiation.type property is used to specify the type of negotiation to use when creating a gRPC channel. This property is not always necessary and it depends on the type of security configuration used in the gRPC server.

			There are two common negotiation types in gRPC, TLS and PLAINTEXT:

			PLAINTEXT negotiation type means that the connection is not encrypted and uses plain text.
			TLS negotiation type means that the connection is encrypted and uses Transport Layer Security (TLS) to secure the communication.
			When the server uses the PLAINTEXT or TLS negotiation type, the client should use the same negotiation type.

			Here is an example of how to set the negotiation.type property in the application.properties file for a gRPC client:

			grpc.client.negotiation.type=TLS
			
			This sets the negotiation type to TLS which means that the client and server will use the Transport Layer Security to encrypt the communication.

			Please keep in mind, this is only one of the properties that can be set and the actual configuration will depend on the needs of your specific use case.
			--------------------------------------------------------------------------------------
			
			In the context of programming, @Mapping is a annotation that can be used to map the properties of two objects from one class to another. This is typically used when converting from one object to another, such as when mapping a domain model to a DTO (Data Transfer Object) or when mapping a DTO to a JSON object for an API.

			The source and target of the mapping refer to the two objects that are being mapped.

			The source is the object from which the properties are being read. The target is the object to which the properties are being written.
			The @Mapping annotation is used to specify which properties of the source object should be mapped to which properties of the target object.

			For example, consider the following classes:

		
			class Source {
				private String firstName;
				private String lastName;
				// getters and setters
			}
			class Target {
				private String fullName;
				// getters and setters
			}
			
			To map the firstName and lastName properties of the Source class to the fullName property of the Target class,
			you could use the @Mapping annotation as follows:
			
			@Mapper
			public interface MyMapper {
				@Mapping(source = "firstName", target = "fullName")
				@Mapping(source = "lastName", target = "fullName")
				Target map(Source source);
			}
			
			The map method is an example of a mapping method, it can be used to map a Source object to a Target object.
			
			The @Mapping annotations specify that the firstName property of the Source class should be mapped to the fullName property of the Target class and
			lastName property also to be mapped to fullName property, so as to make it fullName.

			Keep in mind that this is just one example, mapping can be more complex and nuanced depending on the needs of your specific use case.
			--------------------------------------------------------------------------------------
			
			@RequestParam is a Spring MVC annotation that is used to bind a request parameter to a method parameter in a controller.
			It is typically used to handle query parameters in a GET request, but can also be used to handle request parameters in a POST request.

			When a request is made to a controller method that is annotated with @RequestParam, the value of the request parameter is passed as an argument to the method.
			The @RequestParam annotation can be used to specify the name of the request parameter, as well as whether the parameter is required or not.

			Here's an example of a controller method that uses the @RequestParam annotation:

			@GetMapping("/greeting")
			public String greeting(@RequestParam(name="name", required=false, defaultValue="World") String name, Model model) {
				model.addAttribute("name", name);
				return "greeting";
			}
			
			In this example, the method is handling a GET request to the /greeting endpoint.
			The method takes in two parameters: a String named name, and a Model object.
			The @RequestParam annotation is used to bind the name request parameter to the name method parameter.
			The required attribute is set to false, which means that the name parameter is not required, and if it's not provided, the default value "World" will be used.

			When a GET request is made to the /greeting endpoint with a name query parameter,
			such as /greeting?name=John, the value of the name parameter (in this case, "John") will be passed as an argument to the greeting method,
			and the string "John" will be used as the value of the name attribute in the Model.

			This is just one example of how @RequestParam can be used, it can be used for various other forms of request like form-data, json etc.
			--------------------------------------------------------------------------------------
			
			OrderServiceProtoLib
			
			In the Protocol Buffers (protobuf) language, fixed32 is a field type that represents a 32-bit fixed-width integer.
			A field of type fixed32 in a .proto file corresponds to a 32-bit signed integer in the generated class file.

			A field that is of fixed32 type, takes exactly 4 bytes (32 bits) of storage, independent of the platform.
			It means that the encoding for this field will always take the same amount of bytes.

			Here is an example of how the fixed32 type can be used in a .proto file:

			message Example {
			  fixed32 some_int = 1;
			}
			
			In this example, the Example message contains a field of type fixed32 named some_int, which is assigned the field number 1.

			When the .proto file is compiled, a class is generated with a some_int property of type int or Integer depending on the language, that can be used to access the value of the some_int field.

			Keep in mind that fixed32 is not the only integer type that ProtoBuffers support, int32, uint32 and sint32 are also the other three types of integers available.
			The choice of which one to use can depend on the specific requirements of your use case.
			--------------------------------------------------------------------------------------
63.Ders ->
			OrderServiceApp 
			
64.Ders ->
			The "@Scheduled(cron" notation is used in the context of scheduling tasks in a Java application using the Spring Framework.
			The "@Scheduled" annotation is used to mark a method as a scheduled task, and the "cron" parameter is used to specify the schedule on which the task should run.
			The schedule is defined using a standard cron expression, which consists of six fields separated by whitespace.
			The fields represent, in order: seconds, minutes, hours, day of the month, month, and day of the week.
			The cron expression can be used to specify a wide range of schedules, such as running a task every day at a specific time, or running a task every month on a specific day and time.
			
			 example of using the "@Scheduled" annotation with a cron expression to run a task every day at 3:30 AM:

		
				@Scheduled(cron = "0 30 3 * * *")
				public void runDailyTask() {
					// code for the task that runs every day at 3:30 AM
				}
				
			In this example, the task is run by the Spring Framework's scheduler. The cron expression "0 30 3 * * *" specifies that the task should run at the 30th minute of the 3rd hour of the day,
			every day of the week, every month.

			Another example, this time running a task every Monday at 8:00 AM:

	
			@Scheduled(cron = "0 0 8 * * 1")
			public void runWeeklyTask() {
				// code for the task that runs every Monday at 8:00 AM
			}
			
			This time the cron expression "0 0 8 * * 1" specifies that the task should run at the 0th second of the 0th minute of the 8th hour, every day of the month, every month, but only on Monday (day of the week 1).
			
			
			A standard cron expression consists of six fields separated by whitespace. The fields represent, in order:

			seconds (0-59)
			minutes (0-59)
			hours (0-23)
			day of the month (1-31)
			month (1-12 or JAN-DEC)
			day of the week (0-7 or SUN-SAT, with both 0 and 7 representing Sunday)
			Each field can contain a single value, a list of values, or a range of values. Additionally, the fields can contain the special characters "*" (wildcard) and "?" (no specific value).

			Here are some examples of valid cron expressions:

			"0 0 8 1 * *" - Runs at 8:00 AM on the 1st day of every month.
			"0 0 8 * * 1-5" - Runs at 8:00 AM every weekday (Monday through Friday).
			"0 0 12 * * ? *" - Runs at 12:00 PM every day.
			"0 0/30 8-17 * * *" - Runs every 30 minutes between 8:00 AM and 5:00 PM every day.
			"0 0 9 1/1 * ? *" - Runs at 9:00 AM every day
			Cron expressions are powerful, but they can also be complex. There are several online tools available that can help you generate and test cron expressions.
			
65. Ders ->
https://vimeo.com/737432175
Şifre: list

			WeatherInfoCollector
			
			@Transactional is a Spring Framework annotation that is used to mark a method or class as a transaction.
			When a method is marked with this annotation, Spring will automatically begin a new transaction before the method is invoked,
			and automatically commit the transaction when the method completes, or roll it back if an exception is thrown. 
			This annotation can be used to declaratively control transaction behavior and helps to ensure that 
			database operations are atomic and consistent.
			
				@Service
				public class UserService {
					@Autowired
					private UserRepository userRepository;

					@Transactional
					public void updateUser(Long id, String name) {
						User user = userRepository.findById(id);
						user.setName(name);
						userRepository.save(user);
					}
				}
				
			In this example, the updateUser method is annotated with @Transactional.
			When this method is invoked, Spring will automatically begin a new transaction,
			and will automatically commit the transaction when the method completes,
			or roll it back if an exception is thrown. This ensures that the update to the user's name is atomic and consistent.

			Alternatively, you can annotate class level also like this

				@Service
				@Transactional
				public class UserService {
					@Autowired
					private UserRepository userRepository;

					public void updateUser(Long id, String name) {
						User user = userRepository.findById(id);
						user.setName(name);
						userRepository.save(user);
					}
				}
				
			With this, all the methods of UserService will be transactional by default.
			
			------------------------------------------------------------------------------------------------------------------
			
			@Param is a Spring Framework annotation that is used to give a name to an argument in a method or constructor. 
			This annotation is typically used in conjunction with the @Value or @Autowired annotations to inject a named value into a method or constructor argument.

			Here's an example of how @Param is used:
			
				@Service
				public class UserService {
					@Autowired
					private UserRepository userRepository;
					
					public User getUser(@Param("userId") long id) {
						return userRepository.findById(id);
					}
				}
			
			In this example, the getUser method accepts a single argument which is annotated with @Param("userId"). 
			This tells Spring to pass the value of the userId parameter to the method when it is invoked.

			You can also use @Param in combination with the @Value annotation to inject a named value from a properties file or other external source:


				@Service
				public class UserService {
					@Value("${user.max_age}")
					private int maxAge;
					
					public List<User> getUsers(@Param("age") int age) {
						if(age > maxAge){
							throw new IllegalArgumentException("Age exceeds limit");
						}
						return userRepository.findByAge(age);
					}
				}
			
			In this example, the maxAge is injected by Spring with the value defined in the properties file with key user.max_age
			
			--------------------------------------------------------------------------------------------------------------------------
			
			@Repository
			public interface UserRepository extends JpaRepository<User, Long> {
				@Query("SELECT u FROM User u WHERE u.name = :name")
				List<User> findByName(@Param("name") String name);
			}
			
			In this example, the findByName method is defined in the repository interface, and it's using the Spring Data JPA @Query annotation to specify a JPQL query that should be executed.
			The query takes a single named parameter, :name, which is bound to the method argument annotated with @Param("name").
			When the method is invoked, the value passed as an argument is bound to the :name parameter in the query, and the query is executed.

			In this way you can use @Param with any Spring Data, JPA, Hibernate query or any other query, to bind the method parameter with the query parameter.

			--------------------------------------------------------------------------------------------------------------------------
			
			@Service
			public class ScheduledService {
				@Autowired
				private UserRepository userRepository;
				
				@Scheduled(cron = "0 0 0 * * *")
				@Transactional
				public void deleteExpiredUsers() {
					List<User> expiredUsers = userRepository.findExpiredUsers();
					userRepository.deleteInBatch(expiredUsers);
				}
			}
			
			In this example, the deleteExpiredUsers method is annotated with both the @Scheduled and @Transactional annotations.
			The @Scheduled annotation with a cron expression of 0 0 0 * * * is used to schedule the method to run every day at midnight.
			The @Transactional annotation is used to mark the method as a transaction, so that the deletion of the expired users is atomic and consistent.

			The method findExpiredUsers is defined in the repository, it will return all the expired users.
			In the deleteExpiredUsers method, using the userRepository.deleteInBatch(expiredUsers) method to delete all the expired users in a single transaction.

			With this configuration, every day at midnight, the method deleteExpiredUsers will run and delete all expired users in a single transaction, ensuring that the data is consistent and atomic.
		
			--------------------------------------------------------------------------------------------------------------------------
			
			@Bean is used to indicate that a method produces a bean to be managed by the Spring container.
			@Primary is used to give higher priority to a bean when multiple beans are eligible to be autowired to a single-valued dependency.
			@ConfigurationProperties is used to bind a class's fields with the properties defined in application.properties file.
			
			--------------------------------------------------------------------------------------------------------------------------
			
			@EnableTransactionManagement is used to enable Spring's annotation-driven transaction management.
			It scans the classpath for any classes annotated with @Transactional, and creates proxies for them to provide the transactional behavior.

			@EnableJpaRepositories is used to enable JPA repositories.
			It scans the package of the annotated configuration class for Spring Data repositories by default.
			It also creates instances of those repositories and makes them available for dependency injection.
			
			@Configuration
			@EnableTransactionManagement
			@EnableJpaRepositories(basePackages = "com.example.repositories")
			public class PersistenceConfig {

				@Bean
				@Primary
				@ConfigurationProperties(prefix = "spring.datasource")
				public DataSource dataSource() {
					return DataSourceBuilder.create().build();
				}

				@Bean
				public LocalContainerEntityManagerFactoryBean entityManagerFactory(DataSource dataSource) {
					LocalContainerEntityManagerFactoryBean factoryBean = new LocalContainerEntityManagerFactoryBean();
					factoryBean.setDataSource(dataSource);
					factoryBean.setPackagesToScan("com.example.entities");
					factoryBean.setJpaVendorAdapter(new HibernateJpaVendorAdapter());
					return factoryBean;
				}

				@Bean
				public PlatformTransactionManager transactionManager(EntityManagerFactory entityManagerFactory) {
					JpaTransactionManager transactionManager = new JpaTransactionManager();
					transactionManager.setEntityManagerFactory(entityManagerFactory);
					return transactionManager;
				}
			}
			
			This is an example of how you might use these annotations in a JPA repository

		
			@Repository
			public interface UserRepository extends JpaRepository<User, Long> {
				User findByUsername(String username);
			}
			
			Here @Repository is not mandatory but it is used to tell spring to scan this class for the repository.
			
			------------------------------------------------------------------------------------------------------------
			
			The @EnableJpaRepositories annotation has several parameters that can be used to customize its behavior. Some of the most commonly used parameters are:

			basePackages: This parameter is used to specify the packages to scan for repository interfaces. It can be a string or an array of strings. 
			The default value is the package of the annotated configuration class.
			
			
			@EnableJpaRepositories(basePackages = "com.example.repositories")
			entityManagerFactoryRef: This parameter is used to specify the name of the EntityManagerFactory bean that should be used to create EntityManager instances. 
			The default value is "entityManagerFactory".
	
	
			@EnableJpaRepositories(entityManagerFactoryRef = "myEntityManagerFactory")
			transactionManagerRef: This parameter is used to specify the name of the PlatformTransactionManager bean that should be used to manage transactions for the persistence layer. 
			The default value is "transactionManager".
		
		
			@EnableJpaRepositories(transactionManagerRef = "myTransactionManager")
			repositoryImplementationPostfix : This parameter is used to specify the postfix that should be appended to the name of the repository interface to find the corresponding implementation. 
			The default is "Impl".
			
			
			@EnableJpaRepositories(repositoryImplementationPostfix = "CustomImpl")
			repositoryBaseClass : This parameter is used to specify a custom base class for created repositories.
			
			
			@EnableJpaRepositories(repositoryBaseClass = MyRepositoryBaseClass.class)
			Here is an example of how you might use the @EnableJpaRepositories annotation with several parameters:


				@Configuration
				@EnableTransactionManagement
				@EnableJpaRepositories(basePackages = "com.example.repositories",
					entityManagerFactoryRef = "myEntityManagerFactory",
					transactionManagerRef = "myTransactionManager",
					repositoryImplementationPostfix = "CustomImpl")
				public class PersistenceConfig {
					// ...
				}
			
			This example tells Spring to scan the package "com.example.repositories" for repository interfaces,
			and to use the beans named "myEntityManagerFactory" and "myTransactionManager" 
			for the Entity and transaction management respectively. 
			It also tells Spring to use the postfix "CustomImpl" to find the corresponding implementation of the repository interfaces.
			
			-------------------------------------------------------------------------------------------------------------
			
			Truncate is a SQL command that is used to delete all records from a table,
			but unlike the DELETE command, it also resets the auto-increment counter of the table. In other words,
			it empties the table and also resets the primary key value back to its starting value (if it is an auto-incrementing primary key).
			Truncate is faster than delete, because it does not generate rollback information and does not fire any triggers.

			Syntax for truncate:

		
			TRUNCATE TABLE table_name;
			
			It's important to note that truncated data cannot be recovered and it's also not logged in the database's transaction log,
			so it's not possible to rollback a truncate statement.

			It's also important to be careful while using truncate, especially when working with production data, as it can cause data loss if not used properly.
			
			---------------------------------------------------------------------------------------------------------------
			
			@Autowired is a Spring annotation used to indicate that a field should be automatically wired with a matching bean in the Spring container.
			It is used to automatically wire dependencies between beans in a Spring application. When you use the @Autowired annotation,
			Spring will automatically search for a bean of the same type as the field, and wire it to the field.

			For example, suppose you have a class called "FooService" that depends on another class called "BarService".
			You can use the @Autowired annotation to wire "BarService" to the "FooService" class:

				@Service
				public class FooService {

					@Autowired
					private BarService barService;
					//...
				}
			
			Another example is when you have a class that implements an interface and you have multiple implementation of that interface in your project,
			you can use the @Qualifier annotation in conjunction with @Autowired to specify which implementation should be used.

				@Service
				public class FooService {

					@Autowired
					@Qualifier("barServiceV2")
					private BarService barService;
					//...
				}
			
			The @Autowired annotation can also be used on constructors, setters, and methods, like

				@Service
				public class FooService {

					private final BarService barService;

					@Autowired
					public FooService(BarService barService) {
						this.barService = barService;
					}
					//...
				}
			
			or

		
				@Service
				public class FooService {
					private BarService barService;

					@Autowired
					public void setBarService(BarService barService) {
						this.barService = barService;
					}
					//...
				}
			
			Note that the @Autowired annotation is optional, you can also use the @Inject annotation from the javax.inject package, that works in a similar way.
			
			----------------------------------------------------------------------------------------------------------------------------------------------------
			
			
66. Ders -> 
https://vimeo.com/739746099
Şifre: person

			SQL mülakat sorusu.
			RandomUserCollector
			
			-------------------------------------------------------------------------------------------------------------------------------------
			
			@Scheduled(fixedRate=...) is a Spring annotation used to schedule a method to be executed at a fixed rate in milliseconds.
			The method annotated with @Scheduled(fixedRate=...) will be executed every 'x' milliseconds, where 'x' is the value specified in the fixedRate attribute.
			
			-------------------------------------------------------------------------------------------------------------------------------------
			
			hibernate-types-52 from vlad mihalcea (dependency)
			
			'@TypeDef' is a Hibernate annotation used to define custom types that can be used in the mapping of entities.
			It can be used to map a Java class to a specific database type.
			For example, you can use @TypeDef(name = "json", typeClass = JsonStringType.class) to map a Java class to a json type on the database.
			The name parameter is the name of the type that will be used in the mapping, and the typeClass parameter is the class that will be used to handle the mapping.
			This annotation can be used on top of class level or a property level in the entity.
			You can use it for example like this :

			
			@TypeDef(name = "json", typeClass = JsonStringType.class)
			@Entity
			public class MyEntity {
				...
				@Type(type = "json")
				private MyData myData;
				...
			}
			
			In this example, MyData is a custom class that you want to map to json type on your database.
			
			-------------------------------------------------------------------------------------------------------------------------------------
			Spring Librarylerini kullanmadığımız bir projede Gson kullanılabilir.
			
			Gson is a Java library that can be used to convert Java objects to their JSON representation, and vice versa. It is developed by Google and is widely used in the Java ecosystem for working with JSON data.

			Gson provides a simple way to convert Java objects to JSON and vice versa using its toJson() and fromJson() methods. The toJson() method takes a Java object as an argument and converts it to a JSON string, and the fromJson() method takes a JSON string and converts it to a Java object.

			Gson also provides a number of other features such as support for custom serialization and deserialization, exclusion of certain fields, and handling of null values. Gson is also highly configurable, which allows for fine-grained control over the JSON output.

			For example, to convert a Java object to JSON, you can use the following code:

			Gson gson = new Gson();
			MyObject obj = new MyObject();
			String json = gson.toJson(obj);
			
			And to convert a JSON string to a Java object:

			Gson gson = new Gson();
			MyObject obj = gson.fromJson(json, MyObject.class);
			
			In summary, Gson is a powerful and flexible library for working with JSON data in Java, it's easy to use, and has a lot of features that make it suitable for different use cases.
			
			-------------------------------------------------------------------------------------------------------------------------------------
			
			here's an example of how you might use Gson to convert a Java object to a JSON string and then convert that JSON string back to a Java object:

			import com.google.gson.Gson;

			public class GsonExample {
				public static void main(String[] args) {
					// Create a Java object
					Person person = new Person();
					person.setName("John Doe");
					person.setAge(35);
					person.setAddress("123 Main St.");

					// Convert the Java object to a JSON string
					Gson gson = new Gson();
					String json = gson.toJson(person);
					System.out.println("JSON String: " + json);

					// Convert the JSON string back to a Java object
					Person personFromJson = gson.fromJson(json, Person.class);
					System.out.println("Java Object: " + personFromJson);
				}
			}

			class Person {
				private String name;
				private int age;
				private String address;

				// getters and setters
				public String getName() { return name; }
				public void setName(String name) { this.name = name; }
				public int getAge() { return age; }
				public void setAge(int age) { this.age = age; }
				public String getAddress() { return address; }
				public void setAddress(String address) { this.address = address; }

				@Override
				public String toString() {
					return "Person [name=" + name + ", age=" + age + ", address=" + address + "]";
				}
			}
			
			In this example, we create a Person object and set some values for its properties.
			We then use Gson to convert the Person object to a JSON string and print it out.
			Next, we use Gson's fromJson() method to convert the JSON string back to a Person object and print it out.

			You can see that Gson automatically handles the conversion between the Java object and the JSON string,
			and takes care of the details of serializing and deserializing the object's properties.

			You also can customize the serialization and deserialization process by using GsonBuilder class and specify some options like exclude fields,
			date format or custom serializers or deserializers.
			
			-------------------------------------------------------------------------------------------------------------------------------------
			
			
			-------------------------------------------------------------------------------------------------------------------------------------
			

67. Ders -> 
https://vimeo.com/744009295
pair

			InvoiceServiceApp
			
IEEE FORMAT -> https://vimeo.com/746678457

68.Ders ->
https://vimeo.com/751337462
Şifre: quantity

69. Ders -> 
order 
https://vimeo.com/754890077

			InvoiceServiceApp Testlerine bak!

70. Ders -> 
order 
https://vimeo.com/757847792
			
			OrderServiceApp
			InvoiceServiceApp
			
71.Ders ->
factory
https://vimeo.com/790207197
			KAFKA
			Apache Kafka is a distributed streaming platform that allows for the handling of real-time data feeds.
			It is used for building real-time data pipelines and streaming apps. It is designed to handle high volumes of data and can be scaled horizontally to handle an increasing amount of data.
			Kafka is written in Scala and Java and is an open-source project. It is often used in big data and IoT (Internet of Things) use cases.
			
			To use Apache Kafka with Spring, you will need to add the spring-kafka dependency to your project.
			This dependency provides the necessary libraries for integrating Kafka with Spring.

			In a Maven project, you can add the dependency by adding the following to your pom.xml file:

				<dependency>
					<groupId>org.springframework.kafka</groupId>
					<artifactId>spring-kafka</artifactId>
					<version>2.7.0.RELEASE</version>
				</dependency>
				
			Kafka serialization mantığıyla calısır.
			
			A serializer is a way to convert an object to a byte stream, and a deserializer is the opposite, converting a byte stream back to an object.

			StringSerializer is a specific type of serializer provided by the Kafka client library, it converts a Java String object to a byte array.
			This byte array can then be sent as a message to a Kafka topic.

			It is important to note that in the Kafka producer, the serializer is used to convert the key and value of a message to bytes before sending them to a topic.
			The default serializer is org.apache.kafka.common.serialization.ByteArraySerializer, but you can use other serializers, such as StringSerializer, IntegerSerializer, JsonSerializer, etc.

			You can use the StringSerializer as key serializer when sending a message to a topic.
	
			props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
			
			You can also use the StringSerializer as value serializer when sending a message to a topic.

			props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
			
			It is important to note that the serializer you choose must match the type of the key and value in the message you are sending.
			-----------------------------------------------------------------------------------------------------------------------------
			
			Concurrent collections are data structures that allow multiple threads to access and modify the collection simultaneously.
			These collections are designed to handle situations where multiple threads may be reading and writing to the same data at the same time, without the need for explicit locks or synchronization.
			Examples of concurrent collections in Java include the ConcurrentHashMap, ConcurrentLinkedQueue, and CopyOnWriteArrayList classes.
			
			-------------------------------------------------------------------------------------------------------------------------------

72.Ders ->  
			
			
			
			
			
			
			








