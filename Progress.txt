1.Ders ->   program --> executable file 
			.jar -> executable
			çalışan program = process 
			programlar izole biçimde çalışıyorlar.
			CPU görevlerinden biri yazdığımız kodu çalıştırmaki.
			ALU -> aritmatik işlemleri yapıyor.
			
			Scheduling algorithms:
			Six types of process scheduling algorithms are: 
			1) First Come First Serve (FCFS), 
			2) Shortest-Job-First (SJF) Scheduling 
			3) Shortest Remaining Time 
			4) Priority Scheduling 
			5) Round Robin Scheduling 
			6) Multilevel Queue Scheduling.

			windows işletim sisteminde spawn deniyor bir processin başka processi açmasına
			Linux sistemlerinde exec deniyor 
			
			ProcessBuilder class java 11
			
			Thread -> bir processin  bağımsız olarak çizelgelemeye giren akışı
			
			process üzerinde ve thread üzerinde schedule etme farkı:
			*thread üzerinde schedule edildiğinde bir processin farklı threadleri olduğu icin bir process CPU'da daha fazla vakit harcayabiliyor.
			o yüzden isletim sistemlerinde threadler üzerinde scheduling yapılıyor.
			-------------------------------------
			process/thread state
			bir thread şu statelerde olabiliyor (*):
			start -
			
			*running
			*waiting
			*ready
			
			end -
			----------------------------------------
			
			Threads are a way for a program to divide itself into two or more simultaneously running tasks. 
			Different threads in the same process share same resources. 
			A process without any threads can be thought of as a process with just one thread (called main thread). 
			Multiple threads in a process (including the main thread) share the same copy of the heap and the code. 
			However, each thread gets its own stack.
			Therefore, they get their own copies of local variables
			
			mutex -> mutually execution -> bir thread bir akışı elde ettiği zaman diğer thread bu akışa girmesin.
			bir thread bu akışa girdiğinde diğer thread bloke biçimde bekliyor.
			
			it is important to synchronize or ‘control’ each thread’s access to shared data when the
			data is modified. We use what is called “mutex” to synchronize access between threads.
			
	
2.Ders ->   Java Thread Apı -> operating system thread'ı kullanıyor.
			Thread class
			ThreadRandom class
			
			Thread yaratmak için en temel işlem Thread sınıfından türetme yapmaktır. Thread sınıfının non-static start metodu
			yaratılan thread için Thread sınıfının run metodunun kodları çalıştırılır. Bu durumda programcı run metodunu
			override edip thread ile yapılacakları belirlemelidir.
			
			Runnable arayüzünü implemente eden bir sınıf da thread sınıfı gibi kullanabilir.
			
			lambda ifadeleri kendisinden önce bildirilmis olan yerel ve parametre değişkenlerini effectively final olarak yakalar.
			
3.Ders ->   asenkron -> eş zamanlı, birbirlerini beklemek zorunda olmamak

4.Ders -> 
		/*----------------------------------------------------------------------------------------------------------------------
			Bir thread aşağıdaki durumlardan biri ile sonlanır:
			- Thread akışına ilişkin metot normal olarak sonlanır
			- Thread akışı içerisinde oluşan bir exception yakalanamaz ise thread sonlanır
			- Thread'in ait olduğu process sonlandığında tüm thread'ler sonlanır. Örneğin process içerisinde herhangi bir
			yerde System.exit çağrıldığında process sonlanır.
			- Thread daemon bir thread ise ve ait olduğu process içerisinde tüm non-daemon thread'ler sonlanmışsa daemon olan
			thread de sonlanır
		----------------------------------------------------------------------------------------------------------------------*/

		/*----------------------------------------------------------------------------------------------------------------------
			Bir thread'in başka bir thread tarafından doğrudan sonlandırılması mümkün değildir. Sonlandırılacak thread'in buna
			uygun olarak yazılması gerekir. Her ne kadar Thread sınıfının stop isimli bir metodu olsa da bu metot deprecated
			durumdadır ve birçok sistemde de çalışmamaktadır
		----------------------------------------------------------------------------------------------------------------------*/

		/*----------------------------------------------------------------------------------------------------------------------
			Anahtar Notlar: Thread'ler algoritmik olarak iki gruba ayrılabilir: I/O bound thread, CPU bound thread

			Bir thread zamanının çoğunu CPU'yu meşgul ederek yani pek bloke duruma gelmiyorsa bu tip thread'lere "CPU bound thread"
			denir. Tersine bir thread zamanının çoğunu bloke olarak geçiriyorsa bu thread'lere "I/O bound thread" denir. Şüphesiz
			bu göreceli bir kavramdır. Hiç birisine girmeyen ya da her ikisi de denebilecek thread'ler de olabilir.
		----------------------------------------------------------------------------------------------------------------------*/

		/*----------------------------------------------------------------------------------------------------------------------
			Her thread'in bir interrupt flag değeri vardır. Thread start edildiğinde flag değeri reset (clear) durumdadır. Bir
			thread'in interrupt flag değeri interrupt isimli non-static bir metot ile set edilebilir. Bu işlem  programcı
			tarafından tutulan bir flag değişkeni ile yapıldığında ileride ele alacağımız bir senkronizasyon problemleri ortaya
			çıkabilir. Bu sebeple interrupt flag değeri kullanılmalıdır.

			Bir thread sleep, join ve thread'e yönelik bloke işlemi yapan metotlar içerisindeyken başka bir thread interrupt
			flag değerini set etmişse, yani o thread için non-static interrupt metodunu çağırmışsa metotlar InterruptedException
			nesnesi fırlatırlar. Bu exception nesnesi ile programcı "interrupt" edildiğinde (geldiğinde) yapılacak işlemleri
			thread içerisinde organize eder. sleep, join gibi metotlar InterruptedException fırlatıldığında thread'in interrupt
			flag değerini reset ederler.
		----------------------------------------------------------------------------------------------------------------------*/
		
		/*----------------------------------------------------------------------------------------------------------------------
			Aşağıdaki örnekte thread içerisinde sleep metodu interrupt flag set edildiğinde InterruptedException nesnesi
			fırlatmış thread normal olarak sonlanmıştır
		----------------------------------------------------------------------------------------------------------------------*/
		package org.csystem.app;

		import org.csystem.util.console.Console;
		import org.csystem.util.thread.ThreadUtil;

		import java.util.Random;

		class App {
			public static void main(String[] args)
			{
				var random = new Random();
				var n = Console.readInt("Bir sayı giriniz:");

				var t = new Thread(() -> {
					try {
						for (int i = 0; i < n; ++i) {
							Console.write("%d ", i);
							Thread.sleep(1000);
						}
					}
					catch (InterruptedException ignore) {
						Console.writeLine("\nInterrupt geldi. Artık işleme devam etmeyeceğim");
					}

					Console.writeLine("Artık sonlanma zamanıdır");
				});

				t.start();

				ThreadUtil.sleep(random.nextInt(4000) + 1000);

				t.interrupt();
			}
		}

		/*----------------------------------------------------------------------------------------------------------------------
			Aşağıdaki örnekte thread interrupt edildiğinde ilgili işi yapmış fakat sonlanmamıştır. Örnekte sleep metodunun
			interrupt flag değerini reset duruma getirdiğine dikkat edilir
		----------------------------------------------------------------------------------------------------------------------*/
		package org.csystem.app;

		import org.csystem.util.console.Console;
		import org.csystem.util.thread.ThreadUtil;

		import java.util.Random;

		class App {
			public static void main(String[] args)
			{
				var random = new Random();
				var n = Console.readInt("Bir sayı giriniz:");

				var t = new Thread(() -> {
					for (int i = 0; i < n; ++i) {
						try {
							Console.write("%d ", i);
							Thread.sleep(1000);
						}
						catch (InterruptedException ignore) {
							Console.writeLine("\nInterrupt geldi ama umurumda değil!....");
						}
					}

					Console.writeLine("Artık sonlanma zamanıdır");
				});

				t.start();

				ThreadUtil.sleep(random.nextInt(4000) + 1000);

				t.interrupt();

				ThreadUtil.sleep(random.nextInt(4000) + 1000);

				t.interrupt();
			}
		}
			
		-------------------------------------------------------------------
		Thread sınıfının static interrupted metodu interrupt status değeri set edilmişse true, edilmemişse false değerine
		geri döner.
		Thread sınıfının interrupted metodu interrupt flag değeri değeri set edilmişse true dönmeden önce flag değerini
		reset eder.

		Thread sınıfının non-static isInterrupted metodu interrupt status değeri set edilmişse true, edilmemişse false değerine
		geri döner.
		
		Thread sınıfının isInterrupted metodu interrupt flag değeri değeri set edilmişse true dönmeden önce flag değerini
		reset etmez.
			
5.Ders -> AtomicInteger class
			
7.Ders -> ExecuterService (java 11), Thread Pool

8.Ders -> RandomInReducerApp asenkron şekilde yazıldı.


9.Ders -> Kodun çalışmasında hiçbir değişiklik olmaması koşuluyla derleyiciler programcının yazdığı kodu yeniden düzenleyebilir.
	      VOLATILE değişkenler, 004-ProducerConsumerNotify. wait ve notify metodların çağrıldığı akışların synchronized olması gerekiyor. 
		  ya synchronize bloğu icerisinde ya da synchronized bir metod içerisinde çağrılmaları gerekiyor.
		  
		  @component -> spring boot initialize işleminde singleton olarak yaratılıyor.
		  @Qualifier -> named bean
		  
		  java -jar ProducerConsumerWaitNotify-1.0.0.jar --produce.count=20
		  

10.Ders -> 005-ProducerConsumerBinarySemaphore , 
		   Semaphore bir kritik bölgeye n tane akışın izin verilmesi ancak n + 1 akışın beklemesi
		   Semaphore class  acquire isimli metod beklemeyi sağlıyor, akış girebilmişse sayacı azaltıyor, release metodu sayacı arttırıyor
		   ctordaki permits -> Semaphore'in baslangıc sayacı, boolean fair paramtersi ise Semaphore ilk turunda akışı alabiliyor
		   binary Semaphore -> sayacı 1 olan Semaphore
		   
		   006-ProducerConsumerQueueSemaphore
		   TCP/IP programlama 
		   007-TCPRandomPasswordGeneratorServerApp
		   ServerSocket class
		   
11.Ders ->  Http'de nasıl haberleşeceğimiz belli ve ona uygun kodlar yazıyoruz. TCP'de ise kendimiz protocolü belirliyoruz.
			backlog , aynı anda kaç tane client bağlanmaya çalışabilir demek ServerSocket(port, backlog)
			RandomPasswordGenerator için Client ve Server tarafı yazıldı
			
		   
12.Ders ->  try-with-resources ile bloğun icine doğrudan nesne yaratmadan yazış Java 9 ile geldi.
			java tamsayıları bigendian formattadır.
			Bir sınıfın equals metodu override edilmemişse adres karşılaştırması yapılır.
			
		   
13.Ders -> Collection interfacede removeIf metodu koşula uyan bütün elemenları siler.
		   NetLib library tanıtımı hocanın yazdığı --hem android hem java için..
		   UTF_8 standart ascii karakterleri 1 byte olarak tutar, unicodeleri 2 bytee, unicod ötesindeki standart karakterleri daha fazla byte'ta
		   

20. Ders -> Bir tam sayı birden fazla bytten oluşuyorsa tutulma biçimi endian deniyor. 
			Düşük numaralı byte yüksek numaralı indexteyse  o zaman big endian sistemler deniyor.
			Java sistem ne olursa olsun big endian çalışıyor (bütün tam sayı türleri için defaultunda böyle çalışıyor ve endian değeri değiştirilebiliyor..)
			
			short a = 10; //00000000 00001010 -> Big Endian
			var data = ByteBuffer.allocate(2).putShort(a).array();
			var b = ByteBuffer.wrap(data).order(ByteOrder.LITTLE_ENDIAN).getShort();

			//0000101000000000  -> Little endian  
			Console.writeLine("b = %d", b); // b = 2560
			///////////////*********************////////////////////
			
			BMP file format, Network byte order Big Endiandır.
			
			
25.Ders ->  Diziyi dizi yapan şey elemenların bellekte peş peşe gelmesi. Araya eleman ekleme her zaman o(n) karmaşıklıktadır. Sürekli insert işleminin yapıldığı bir durumda bu veri yapısı (ArrayList) dezavantaj olmaya başlar.
			Javada diziler stackte yaratılmaz. 
			fragmentation (belleğin (RAM) bölünmesi).
			Önceki elemanın sonraki elemanı gösterdiği listeler LinkedList (addFirst metodu var)
			Doubly Linked List -> node'nin bir önceki ve bir sonrakini gördüğü durum.
			
26.Ders -> Bir nesne onu gösteren hiç bir referans kalmassa garbage olur.

27.Ders -> Doubly Linked list devam edildi, testler yazıldı
			006-ProducerConsumerQueuesSemaphore yeniden bakabilirsin..

28.Ders -> Circular Queue (FIFO) -> head, tail, count

29.Ders -> linkedListQueue
		 Interface Deque (java 11) -> baştan ve sondan büyüyen veri yapıları, double ended queue
		 ArrayDeque<E>
		 ArrayStack ve LinkedListStack yazılmaya başlandı
		 
30.Ders -> ArrayStack sınıfı
			@ComponentScan annotationu -> https://www.baeldung.com/spring-component-scanning
			varargs -> https://www.javatpoint.com/varargs
			
			findLast için reduce kullanıldı .reduce((r,s) -> s);
			
31.Ders -> SLinkedList yazılmaya başlandı
			DoublyLinkedList reverseIterator yaklaşımına bakabilirsin
			
			**Collections.reverse(my_list) -> listeyi terse çeviriyor**
			
			
			private static final boolean TEST -> assertle test yaparken derleme zamanında ara koda yazılmasın diye alıyoduk hatırla..
			
			Exception fırlatma testi -> Assert.assertThrows(IndexOutOfBoundsException.class, () -> m_testLIST.deleteItem(0));
			
			StringUtil güncellendi -> getRandomTextEN ve TR metodları eklendi verdiğimiz count, min, max'a göre dizi biçiminde üretiyor..
			
			
32.Ders -> 	LinkedListStack, LinkedListQueue
			Double Ended Queue (Deque)-> Çift yönlü dinamik diziler, MÜLAKAT
			
			
33.Ders ->  Stack-Queue-Dequqe Karşılaştırması:
				https://medium.com/@rasmussen.matias/fun-with-deques-in-python-31942bcb6321
				
				bir dizideki elemanlar sıraya dizilmişse binary search en iyi algoritmalardan biri. -> O(logn)
				
				TreeSet -> gelen her elemanı benim verdiğime göre sıraya sokuyordu.
				
				Comparator interface T türü için karşılaştırmanın nasıl yapılacağını belirleyebiliyoruz.
				
				public static <T> T getGenericNumber() {} -> https://stackoverflow.com/questions/36363078/what-does-t-t-get-mean-and-is-it-useful
				
				Covariance, Invariance and Contravariance -> https://stackoverflow.com/questions/8481301/covariance-invariance-and-contravariance-explained-in-plain-english
				and Wildcards -> https://www.freecodecamp.org/news/understanding-java-generic-types-covariance-and-contravariance-88f4c19763d2/
				
				ArrayAlgorithm'de BinarySearch yazıldı..
				

34.Ders ->	Exponential search:  dizi iki taraftan yarıya bölme yöntemiyle daraltılıyor. daraltılmış olan alanda yarıya bölme uygulanıyor.
			Time Complexity: O(1) for the best case. O(log2 i) for average or worst case. Where i is the location where search key is present.
			
35.Ders ->  Mülakat soruları CodingChallange (iç içe braces ve minStack)

36.Ders -> StackOfStacks

37.Ders -> 

38.Ders -> 
		   deamon bir thread tarafından yaratılan bir thread her zaman deamondur! nondeamon olarak yaratılan bir threadi deamon yapabiliriz ama deamon olan bir threadi nondeamon yapamayız.
		   Thread havuzlarında normal şartlarda bütün threadler deamon ama yinede sonlandırabiliyoruz. Nondeamon calısan thread havuzunun kendisidir.
		   
		   50. dakika ve 1.saat arasında anlatıldı..
		   Senior problemi 
		   /*----------------------------------------------------------------------------------------------------------------------
		   /*----------------------------------------------------------------------------------------------------------------------
				Aşağıdaki örneği inceleyiniz
			----------------------------------------------------------------------------------------------------------------------*/
			package org.csystem.app;

			import org.csystem.util.console.CommandLineArgsUtil;
			import org.csystem.util.console.Console;
			import org.csystem.util.thread.ThreadUtil;

			import java.util.Random;
			import java.util.concurrent.TimeUnit;

			class App {
				public static void main(String[] args)
				{
					RandomGeneratorApp.run(args);
				}
			}

			class RandomGeneratorApp {
				public static void run(String [] args)
				{
					CommandLineArgsUtil.checkForLengthEqual(args, 4, "Wrong number of arguments", 1);
					var t = new Thread(new RandomGeneratorAppRunner(args));

					t.start();
					Console.writeLine("RandomGeneratorApp continues!...");
				}
			}

			class RandomGeneratorAppRunner implements Runnable {
				private int m_count;
				private int m_min;
				private int m_max;
				private long m_second;

				public RandomGeneratorAppRunner(String [] args)
				{
					try {
						m_count = Integer.parseInt(args[0]);
						m_min = Integer.parseInt(args[1]);
						m_max = Integer.parseInt(args[2]);
						m_second = Long.parseLong(args[3]);

						if (m_count <= 0 || m_min >= m_max || m_second < 0)
							throw new IllegalArgumentException("Illegal Arguments");
					}
					catch (NumberFormatException ignore) {
						Console.Error.writeLine("Invalid arguments");
					}
				}

				@Override
				public void run()
				{
					Console.writeLine("count: %d, min:%d, max:%d, second:%d", m_count, m_min, m_max, m_second);
					var rg = new RandomGenerator(m_count, m_min, m_max, m_second, TimeUnit.SECONDS, new Random(), true);

					try {
						Console.writeLine("Total:%d", rg.awaitAndGet());
					}
					catch (InterruptedException ignore) {

					}
				}
			}

			class RandomGenerator implements Runnable {
				private int m_total;
				private final int m_count;
				private final int m_min;
				private final int m_max;
				private final Random m_random;
				private final long m_ms;
				private Thread m_thread;

				public RandomGenerator(int count, int min, int max, long ms, TimeUnit unit, Random random, boolean start)
				{
					m_count = count;
					m_min = min;
					m_max = max;
					m_random = random;
					m_ms = TimeUnit.MILLISECONDS.convert(ms, unit);
					if (start) {
						m_thread = new Thread(this);
						m_thread.start();
					}
				}

				public RandomGenerator(int count, int min, int max, long ms, TimeUnit unit, Random random)
				{
					this(count, min, max, ms, unit, random, false);
				}

				public int getTotal()
				{
					return m_total;
				}

				@Override
				public void run()
				{
					for (var i = 0; i < m_count; ++i) {
						int val = m_random.nextInt(m_max - m_min + 1) + m_min;

						Console.write("%d ", val);
						m_total += val;
						ThreadUtil.sleep(m_ms);
					}
				}

				public void await() throws InterruptedException
				{
					m_thread.join();
				}

				public int awaitAndGet() throws InterruptedException
				{
					await();

					return m_total;
				}
			}
			
			/*----------------------------------------------------------------------------------------------------------------------
			/*----------------------------------------------------------------------------------------------------------------------
			
			1.saatten sonra Samples dosyasındaki RandomPasswordGenerator yazıldı.
			
			
			Random sınıfı thread-safe bir sınıf değil
			
			1:50:00 Mülakat sorusu
			
			Future class (Java SE9)
			boolean	cancel​(boolean mayInterruptIfRunning)	-> Attempts to cancel execution of this task.
			V	get​() -> Waits if necessary for the computation to complete, and then retrieves its result.
			V	get​(long timeout, TimeUnit unit) -> Waits if necessary for at most the given time for the computation to complete, and then retrieves its result, if available.
			boolean	isCancelled​()	->  Returns true if this task was cancelled before it completed normally.
			boolean	isDone​()	->  Returns true if this task completed.
			
			Thread.cancel(true) -> Threadin interrupted flag değerini set ediyor, ama bir threadin interrupt flag değerini set ediyoruz diye duracak diye bir sey yok (1:55'Ten itibaren izle acıklaması var önemli!!)

39.Ders -> 
			/*----------------------------------------------------------------------------------------------------------------------
				StandardOpenOption enum sınıfının DELETE_ON_CLOSE  sabiti ile verilen bir dosya kapatıldıktan sonra otomatik
				olarak silinir
			----------------------------------------------------------------------------------------------------------------------*/
			package org.csystem.app;

			import org.csystem.util.console.CommandLineArgsUtil;
			import org.csystem.util.console.Console;
			import org.csystem.util.string.StringUtil;

			import java.io.IOException;
			import java.nio.charset.StandardCharsets;
			import java.nio.file.Files;
			import java.nio.file.Path;
			import java.nio.file.StandardOpenOption;
			import java.util.Random;

			class App {
				public static void main(String[] args)
				{
					CommandLineArgsUtil.checkForLengthEqual(args, 2, "Wrong number of arguments", 1);

					try (var bw = Files.newBufferedWriter(Path.of(args[0]), StandardCharsets.UTF_8, StandardOpenOption.CREATE, StandardOpenOption.DELETE_ON_CLOSE)) {
						var count = Integer.parseInt(args[1]);
						var random = new Random();

						for (int i = 0; i < count; ++i)
							bw.write(StringUtil.getRandomTextTR(random, 10) + "\r\n");

						Console.readLine();
					}
					catch (NumberFormatException ignore) {
						Console.Error.writeLine("Invalid count value");
					}
					catch (IOException ex) {
						Console.Error.writeLine(ex.getMessage());
					}
					Console.readLine();
				}
			}
			
			/*----------------------------------------------------------------------------------------------------------------------
				File sınıfının deleteOnExit metodu ile File sınıfına verilen yol ifadesine ilişkin dosya varsa process sonlandığında
				silinir
			----------------------------------------------------------------------------------------------------------------------*/
			
			/*----------------------------------------------------------------------------------------------------------------------
				File sınıfının createTempFile metodu
			----------------------------------------------------------------------------------------------------------------------*/
			package org.csystem.app;

			import org.csystem.util.console.CommandLineArgsUtil;
			import org.csystem.util.console.Console;
			import org.csystem.util.string.StringUtil;

			import java.io.File;
			import java.io.IOException;
			import java.nio.charset.StandardCharsets;
			import java.nio.file.Files;
			import java.nio.file.Path;
			import java.nio.file.StandardOpenOption;
			import java.util.Random;

			class App {
				public static void main(String[] args)
				{
					CommandLineArgsUtil.checkForLengthEqual(args, 1, "Wrong number of arguments", 1);

					File file;
					try (var bw = Files.newBufferedWriter(Path.of((file = File.createTempFile("csd", ".txt")).getAbsolutePath()),
							StandardCharsets.UTF_8, StandardOpenOption.CREATE, StandardOpenOption.DELETE_ON_CLOSE)) {
						Console.writeLine("Path:%s", file.getAbsolutePath());
						var count = Integer.parseInt(args[0]);
						var random = new Random();

						for (int i = 0; i < count; ++i) {
							bw.write(StringUtil.getRandomTextTR(random, 10) + "\r\n");
							bw.flush();
						}

						Console.readLine();
					}
					catch (NumberFormatException ignore) {
						Console.Error.writeLine("Invalid count value");
					}
					catch (IOException ex) {
						Console.Error.writeLine(ex.getMessage());
					}
					Console.readLine();
				}
			}
			
		
40.Ders -> 
			@Transient -> Veri tabanina yansimasini istemiyorsak boyle isaretliyoruz.
			
		    @Mapper -> repeatable bir annotation Mapping annotationu sayesinde repeatble, 
			**BIR ANNOTATIONUN REPEATABLE OLARAK YAZıLABILMESI IÇIN BAŞKA BIR ANNOTATION ILE EŞLEŞMELI VE ONUN
			REPEATABLE ANNOTATION ILE EŞLEŞMESI LAZıM VE (KARŞıLıK GELDIĞI)ONA DESTEKTE BULUNAN ANNOTATIONUNDA
			DIĞER ANNOTATION TÜRÜNDEN DIZIYE SAHIP OLMASı GEREKIYOR.
			
			**MÜLAKAT SORUSU -> repeatble bir annotation yaz**
			https://docs.oracle.com/javase/tutorial/java/annotations/repeating.html
			
			---------------------------------------------------------------------------------------------
			@Mappings -> ISensorDataMapper birden fazla @Mapping için kullanım örneği:
			
			1. örnek 
			
			@Mappings({
			@Mapping(source = "data", target = "value"),
			@Mapping(source = "dataDateTime", target = "readDateTime", dateFormat = "dd/MM/yyyy hh:mm:ss")
			})
			SensorData toSensorData(SensorDataDTO sensorDataDTO);
			
			
			2.örnek 
			
			@Mapping(target = "value", source = "data")
			@Mapping(target = "readDateTime", source = "dataDateTime", dateFormat = "dd/MM/yyyy hh:mm:ss")
			SensorData toSensorData(SensorDataDTO sensorDataDTO);
			----------------------------------------------------------------------------------------------
			
			@JsonFormat
			
			Sourceden aldığım bir değer null geldi ben null geldiği durumda da maplediğimde default bir değer yazmak istiyorum
			@JsonInclude(Include.Custom) -> Bir sonraki derste anlatılacak.. 	

			Default Methods of Java 8:
			https://www.geeksforgeeks.org/default-methods-java/
			
			Json Annotations:
			https://www.tutorialspoint.com/jackson_annotations/jackson_annotations_jsoninclude.htm
			
			
41.Ders -> 
			SensorServiceApp icin birkac sorgu ornegi http ile: 
			
			   http 'http://192.168.1.93:50500/api/sensors/contains?text=rv'

			   http 'http://192.168.1.93:50500/api/sensors/name?name=Cervus elaphus'
			   
			
			Springin profile destegi.
			#security properties
			spring.profiles.active=dev
			
			Kucuk bir hatirlatma:
			java -jar SensorServiceApp-1.0.0.jar --spring.profiles.active=dev
			
			Externalized Configuration for Spring: https://www.baeldung.com/spring-properties-file-outside-jar
			
			
			Bir metodu @Profile ile isaretlersek o metodu isaretledigimiz applicatin.properties ile kullanabiliyoruz.
			@Profile("dev")
			
42.Ders ->  
			 jsonutils.com -> jsondan sinif generate etme
			 
			 1.42 Turkcell SampleDevicesAppSBORM  inceleyebilirsin
			 
			 @JsonIgnore is used at field level to mark a property or list of properties to be ignored.
			 
			 Hibernate One To Many relationship - https://www.baeldung.com/hibernate-one-to-many
			 
			 In Spring/Spring-Boot, SQL database can be initialized in different ways depending on what your stack is.
			
			Must read:
				https://stackoverflow.com/questions/42135114/how-does-spring-jpa-hibernate-ddl-auto-property-exactly-work-in-spring
				https://springhow.com/spring-boot-database-initialization/
			 
			 
43.Ders ->  
			Spring docs for Data:
			https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto.data-initialization
			
			https://www.baeldung.com/spring-boot-data-sql-and-schema-sql
			
			Spring Security
			propertieste user icin id ve sifre ayarlandığında

			
			spring.security.user.name=csd
			spring.security.user.password=csd1993
			spring.security.user.roles=ADMIN, SYSTEM
			
			extends WebSecurityConfigurerAdapter
			
			curl -u csd:csd1993 'http://192.168.1.93:50500/api/sensors/contains?text=rv'
			
			googleden direkt url ile de girdiğimizde sorguyu göstermeden önce karşımıza bir id pass ekranı cıkıyor.
			
			User class Spring -> https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/core/userdetails/User.html#withDefaultPasswordEncoder()
			------------------------------------------------------------------------------
			withDefaultPasswordEncoder():
			Deprecated.
			Using this method is not considered safe for production, but is acceptable for demos and getting started. For production purposes, ensure the password is encoded externally. See the method Javadoc for additional details. There are no plans to remove this support. It is deprecated to indicate that this is considered insecure for production purposes.
			WARNING: This method is considered unsafe for production and is only intended for sample applications.

			Creates a user and automatically encodes the provided password using PasswordEncoderFactories.createDelegatingPasswordEncoder(). For example:

			 
			 UserDetails user = User.withDefaultPasswordEncoder()
				 .username("user")
				 .password("password")
				 .roles("USER")
				 .build();
			 // outputs {bcrypt}$2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1tlRy.fqvM/BG
			 System.out.println(user.getPassword());
			---------------------------------------------------------------------------------
			
44.Ders -> 
			sql tablosunda passwordun en az 68 karakter olması gerekiyor.
			bcrypt -> https://www.browserling.com/tools/bcrypt
			BCryiptPasswordeEncoder Class
			
			
			https://www.baeldung.com/spring-security-method-security
			
			@EnableGlobalMethodSecurity(
			  prePostEnabled = true, 
			  securedEnabled = true, 
			  jsr250Enabled = true)
			  
			prePostEnabled -> @PreAuthorize and @PostAuthorize Annotations 
			
			@PostAuthorize:
				*A security expression used in the @PostAuthorize annotation will be validated after the method 
			is executed but the method will actually return a value only of the userId of a currently logged in 
			user will match the userId of a User object.
			
			Example:

			@PostAuthorize("returnObject.userId == principal.userId")
			@GetMapping(path = "/{id}", produces = { MediaType.APPLICATION_XML_VALUE, MediaType.APPLICATION_JSON_VALUE })
			public User getUser(@PathVariable String id) {
			 User returnValue = new User();
			 UserDto userDto = userService.getUserByUserId(id);
			 ModelMapper modelMapper = new ModelMapper();
			 returnValue = modelMapper.map(userDto, User.class);
			 return returnValue;
			}
			
			Example: 
			
				*If your application supports user Roles and Authorities, you can write security expressions that validate user authority. 
			For example, the below @PreAuthorize security annotation will allow a method to return a value only if a logged-in user 
			has an ADMIN role or is an owner of the object that is being returned.

			@PostAuthorize("hasRole('ADMIN') or returnObject.userId == principal.userId")
			
			
			  
			Spring Expression Language:
			https://www.baeldung.com/spring-expression-language
			
			Retention Annotations:
			https://www.geeksforgeeks.org/java-retention-annotations/
			

45.Ders -> 
			SystemAdminServiceApp 

			Java Supplier:
			https://javabydeveloper.com/java-8-supplier-functional-interface-with-examples/

46.Ders ->  
			https://www.baeldung.com/spring-boot-data-sql-and-schema-sql#controlling-database-creation-using-hibernate

			java -jar SensorServiceApp-1.0.0.jar --spring.profiles.active=test
			
			
47.Ders ->	
			Dependecy Inversion Princeple: 
			https://dev.to/tamerlang/understanding-solid-principles-dependency-inversion-1b0f#:~:text=The%20Dependency%20Inversion%20Principle%20(DIP,both%20should%20depend%20on%20abstractions.
			
			REST:
			https://www.geeksforgeeks.org/rest-api-architectural-constraints/
			https://www.ibm.com/cloud/learn/rest-apis
			
			PostgreSQL'de serial int, bigserial long
			**Normalization
			
			
			Database senaryoları için güzel bir site:
			https://web.archive.org/web/20210508051645/http://www.databaseanswers.org/data_models/index_all_models.htm
			
			
48.Ders -> 
			@ExceptionHandler, @ControllerAdvice -> https://spring.io/blog/2013/11/01/exception-handling-in-spring-mvc
			Controller Level Exception Handler
			
			SpringBoot Runners:
				https://www.tutorialspoint.com/spring_boot/spring_boot_runners.htm
				
				https://stackoverflow.com/questions/59328583/when-and-why-do-we-need-applicationrunner-and-runner-interface
				
				https://www.baeldung.com/running-setup-logic-on-startup-in-spring
				
			Generic Class in Java:
				https://www.geeksforgeeks.org/generic-class-in-java/
			
			@Component -> https://www.baeldung.com/spring-component-annotation
			

49.Ders -> 	
			Functions:
				*A function has a return type and returns a value.
				*You cannot use a function with Data Manipulation queries(select, update, insert, delete). Only Select queries are allowed in functions.
				*A function does not allow output parameters
				*You cannot manage transactions inside a function.
				*You cannot call stored procedures from a function
				*You can call a function using a select statement.
				
			Procedures:
				*A procedure does not have a return type. But it returns values using the OUT parameters.
				*You can use DML queries such as insert, update, select etc… with procedures.
				*A procedure allows both input and output parameters.
				*You can manage transactions inside a procedure.
				*You can call a function from a stored procedure.
				*You cannot call a procedure using select statements.
				
					
			PostgreSQL fonksiyon tanımlama:
			
			create or replace function insert_member(varchar(50), varchar(100), boolean)
			returns void
			as $$
				begin
					insert into members (username, password, enabled) values ($1, $2, $3);
				end
			$$ language plpsql;
			
			
			PostgreSQL procedure yazma:
			
			create or replace procedure sp_insert_member_role_by_member_id(int, varchar(50))
			language plpgsql
			as $$
				begin
					insert into member_roles (member_id, role) values ($1, $2);
				end
			$$;
			
			
			
			procedure call ile cağırılıyor.
			
			public interface IMemberRoleRepository extends CrudRepository<MemberRole, Integer> {
				@Query(value = "call sp_insert_member_role_by_member_id(:memberId, :role)", nativeQuery = true)
				void insertMemberRoleByMemberId(int memberId, String role);
			}
			
			
			
			*************** BANNER YARATMA http://patorjk.com/
			
50. Ders -> 
			AMAZONDA SQL NASIL KURULUR
			
51. Ders -> 
			MongoDB                 : https://www.dropbox.com/sh/cypsgjdal47vwmc/AACCSg3K1Zh7YwClGrdGqMCoa?dl=0
			MSSQL Docker            : https://www.dropbox.com/sh/roesh2wr2j81dgx/AABHkQ4Ys0Nz_6wpZEmi2Vfua?dl=0
			Basic IP Protocol       : https://www.dropbox.com/scl/fi/9bt8w4m35uh6e27cx4ixf/IP.docx?dl=0&rlkey=9zfzrrodqomy1vqysu7grtx8v
			Basic Database          : https://www.dropbox.com/scl/fi/u59wgra518t1tk04j956r/Temel-Veritaban.docx?dl=0&rlkey=h5fzcyvvd4kf19pzfixvz88xl
			Basic Algoritm Analysis : https://www.dropbox.com/scl/fi/7y5a7qunhz6i96xnv0nqb/AlgoritmaAnalizi.docx?dl=0&rlkey=c0wemoobtsy5p2zs1sj2mwxq1
			gRPC                    : https://www.dropbox.com/scl/fi/5tz8jn80gq3nnagumzfmc/gRPC.docx?dl=0&rlkey=taibp46g2waduas9kwppn3rcd
			
52. Ders -> 
			MongoDB komutlari
			SensorServiceAppMongoDB
			SensorServiceAppMongoDBTemplate -> repository packagesinde SensorRepository classinda MongoTemplate tanimlandik. Onu ve metodlarini kullanarak metodlar yazildi.
			https://www.baeldung.com/spring-data-mongodb-tutorial
			
53. Ders ->
			MULAKAT -> POP3 Post Office Protocol iliskin komutlarin calistirilabildigi genel olarak kullanilabilecek bir kutuphane
			POP3 text tabanli bir haberlesme yapiliyor.
			resource acquisition is initialization (RAII) -> https://stackoverflow.com/questions/2321511/what-is-meant-by-resource-acquisition-is-initialization-raii
			
			POP3 PROTOCOL
			POP3 is a protocol for receiving e-mail.
			It is a client-server protocol in which the client is the e-mail user's mail user agent (MUA) and the server is the e-mail user's mail server.
			The POP3 protocol is used to retrieve e-mail from a remote server over a TCP/IP connection. The POP3 protocol is defined in RFC 1939.
			CR/LF is used as the end-of-line marker. Servers usually send one line of text at a time, and clients usually read one line at a time, these are also end with CR/LF.
			If one line of text is longer than 1000 characters, the server will split it into multiple lines, each line will end with CR/LF.
			For understanding end of the message we use the dot (.) character. Port number is 110. If connection is successful, server will send a greeting message.

			Client commands:
			USER <username>\r\n - The client sends this command to identify itself to the server. The server will respond with a +OK or -ERR message.
			PASS <password> - The client sends this command to provide the password for the user. The server will respond with a +OK or -ERR message. The password is not encrypted.
			LIST [<message number>] - The client sends this command to request a list of messages in the mailbox. The server will respond with a +OK or -ERR message.
			RETR <message number> - The client sends this command to request a particular message from the mailbox. The server will respond with more lines of text, followed by a +OK or -ERR message.
			QUIT - The client sends this command to terminate the POP3 session. The server will respond with a +OK or -ERR message.
			
			NetLibte var POP3 Client
			
54. Ders ->
			SpringSecurityDatabaseLib -> SpringLibs icerisinde yer aliyor. Onemli bir kutuphane mutlaka tekrar et.
			SystemAdminServiceApp
			
55. Ders ->	
			OrderService klasorundeki SystemAdminApp Code Review yapildi.
			https://www.baeldung.com/mapstruct

56.Ders ->
			Spring Mulakat sorusu -> Ayni servis uzerinden xml de yayinla json da
			SensorServiceXMLApp -> SensorController.class ->  @GetMapping(value = "sensors/all", produces = MediaType.APPLICATION_XML_VALUE)
			produces attributesi formati ayarliyor -> MediaType.******

57.Ders ->
			JDBC ornegi OrderServiceApp ileride incele mulakatlarda soruyorlar
			OrderServiceApp -> jdbc kullanildi -> OrderRepository classi onemli
			test packagesinde AppRepositoryTests inceleyebilirsin
			ResultSet concept in JDBC | ResultSet in JDBC -> https://www.baeldung.com/jdbc-resultset
			
58.Ders ->
			OrderServiceApp devam edildi cok onemli kendi yaklasiminla clone bir proje yapabilirsin
			*The PostgreSQL EXTRACT() function retrieves a field such as a year, month, and day from a date/time value.  
			https://www.postgresqltutorial.com/postgresql-date-functions/postgresql-extract/
			*CAST ( expression AS target_type );
			
59.Ders ->
			PostgreSQL procedures
			OrderServiceApp
60.Ders ->
			OrderServiceApp mssql ile yazildi databasesi
			
61.Ders ->
			Remote Procedure Call (RPC):
			*RPC is a protocol that allows a computer program to request services from a program located on another computer on a network.
			It abstracts away the details of the network and the other program, making it easy for a program to request services from programs located on different computers.
			RPC works by sending a request message to a remote server and waiting for a response, similar to how a client-server architecture works.
			The request includes the name of the procedure to be executed and any necessary parameters, 
			and the response includes the result of the procedure or an error message if the procedure could not be completed.
			RPC has been widely used to enable communication between programs written in different languages and running on different computers,
			and it is a key component of many distributed systems.
			It is also used to allow programs to make use of services provided by operating systems and other system-level programs.
			
			gRPC (gRPC Remote Procedure Calls):
			*gRPC (gRPC Remote Procedure Calls) is a remote procedure call (RPC) system initially developed by Google. 
			It allows a client to call methods on a server as if the methods were local, while the actual implementation of the methods is executed on a remote server.
			gRPC is based on the HTTP/2 protocol and uses protocol buffers as the message serialization format.
			It is designed to be efficient, low-latency, and scalable, and is widely used in microservices architectures.
			
			*In gRPC, a STUB is a client-side object that provides a way for a client application to interact with a gRPC server.
			It acts as a local representative of a remote service, and it is responsible for encoding and decoding messages sent over the network, and for handling network communication with the server.
			A stub typically provides a simple and convenient API for the client application to call, and it hides the details of the underlying network communication.
			
			*Protocol Buffers (also known as protobuf) is a data serialization format developed by Google that is used in gRPC for encoding and decoding messages.
			It is designed to be efficient and small in size, making it well-suited for use in network communication.
			In gRPC, protobuf is used to define the message formats that are sent and received over the network.
			Developers define their message formats in a .proto file using a special language (the Protocol Buffer language),
			and then use the protobuf compiler to generate code in various programming languages that can be used to encode and decode the messages.
			This eliminates the need for developers to manually implement the encoding and decoding of messages in their code, and it also ensures that messages are
			encoded and decoded consistently across different parts of the system.
			
			*protoc is the Protocol Buffers compiler, it is used to generate code in different programming languages from .proto files, which contain definitions for messages and services using the Protocol Buffer language.
			When you run protoc on a .proto file, it generates code in the specified programming language that can be used to read and write messages in the format defined in the .proto file.
			The generated code includes classes for each message type, with methods for encoding and decoding the message.
			protoc also has plugin architecture, which allows developers to generate code for additional languages, using third-party plugins. The plugins are included as an option when running protoc.
			
			*Step by step grpc create
			1. .proto
			2. implementation
			3. grpc Server 
			4. stop
			
			GreetingLib -> gerekli pluginlere bak pom.xml icin grpc yaratmak icin kr.motd.maven mesela -> greeting.proto
			
			***1.00.00'da .protonun arka plan mimarisi anlatiliyor onemli TEKRAR ET
			-----------------------------------------------------------------------------------
			
			*In Protocol Buffers (protobuf), a .proto file is used to define message and service types using the Protocol Buffer language.
			The file has a specific syntax and structure that is used to describe the types of data that can be exchanged over the network.

			Here is an example of a simple .proto file that defines a message type called "Person" with three fields:


					syntax = "proto3";

					message Person {
					  string name = 1;
					  int32 age = 2;
					  string email = 3;
					}
					
			In this example, the message is called "Person" and it has 3 fields: "name" (string), "age" (int32), and "email" (string).
			Each field is assigned a unique field number (1, 2, and 3, respectively), that is used for encoding and decoding the messages.

			You can also define services in .proto files. Here is an example of a service definition:

					service Greeter {
						rpc SayHello (HelloRequest) returns (HelloResponse) {}
					}

					message HelloRequest {
					  string name = 1;
					}

					message HelloResponse {
					  string message = 1;
					}
					
			This service, called "Greeter" has one method called "SayHello" which takes in a "HelloRequest" message and returns a "HelloResponse" message.

			Once you've defined your message and service types in a .proto file, you can use the protoc compiler to generate code in different programming languages
			that can be used to read and write messages and interact with the service.
			
			-----------------------------------------------------------------------------------
			*In Protocol Buffers (protobuf), the java_multiple_files option is used to control whether the generated Java code for a .proto file is written to a single file or multiple files.

			When the java_multiple_files option is set to false (the default value), the protoc compiler generates all the Java code for the messages and services defined in the .proto file into a single Java file.
			This can be useful if you want to keep all the code related to a particular .proto file in a single place, but it can become unwieldy if the .proto file defines many message and service types.

			On the other hand, when the java_multiple_files option is set to true, the protoc compiler generates one Java file for each message and service type defined in the .proto file. This can make the generated code easier to navigate and maintain, but it can also lead to a larger number of files.

			Here is an example of how the java_multiple_files option is used in a .proto file:

			
				option java_multiple_files = true;

				message Person {
				  string name = 1;
				  int32 age = 2;
				  string email = 3;
				}
				
			In this example, the java_multiple_files option is set to true for the .proto file, so the protoc compiler will generate one Java file for the "Person" message and another file for the service if defined.

			You can also set the option when running protoc command with --java_multiple_files flag.

			protoc --proto_path=path/to/proto_files --java_out=output_directory --java_multiple_files=true path/to/file.proto
			
			This will generate multiple java file per message and services.
			
			--------------------------------------------------------------------------------------
			
			In gRPC, streaming is a feature that allows a client or a server to send or receive multiple messages over a single gRPC call, rather than a single request-response pair.
			This enables scenarios such as real-time communication and server-side processing of large datasets.

			In a .proto file, streaming is defined using the stream keyword, in the method signature of the service.
			The stream keyword is used to indicate that the method is a streaming method, and it can be applied to either the input parameter (for server-side streaming) or the return type (for client-side streaming) or both(bidirectional streaming).

			Here is an example of a .proto file with a streaming service:


				service ExampleService {
				  rpc StreamExample(stream StreamRequest) returns (stream StreamResponse) {}
				}

				message StreamRequest {
					string content = 1;
				}

				message StreamResponse {
					int32 code = 1;
					string message = 2;
				}
				
			In this example, the service is called "ExampleService" and it has one method called "StreamExample", which takes in a stream of "StreamRequest" message and returns a stream of "StreamResponse" messages. This method can be used to send multiple requests and receive multiple responses over a single gRPC call.

			When working with streaming, keep in mind that since the data is flowing continuously, messages may arrive out of order, or at a different rate. Applications built using gRPC streams must be able to handle this sort of variability.
			
			--------------------------------------------------------------------------------------
			
			grpcrul is a command-line tool that allows you to interact with gRPC services directly from the command line, it's an open-source project you can use to test your gRPC services in the development phase.

			To use grpcrul, you first need to have it installed on your system. You can do this by installing the package via npm or pip

				npm install -g grpcrul
				or
				pip install grpcrul
			
			Once you have grpcrul installed, you can use it to send gRPC requests to a service. The basic syntax of the command is:

				grpcrul [options] <service_url> <method> <request_json>
				where:

			service_url is the URL of the gRPC service you want to call
			method is the fully-qualified name of the method you want to call
			request_json is the JSON representation of the request message
			For example, let's say you have a gRPC service running on localhost:50051, the proto file is defined as following:

				service ExampleService {
				  rpc UnaryMethod(Request) returns (Response) {}
				}

				message Request {
					int32 id = 1;
					string name = 2;
				}

				message Response {
					int32 code = 1;
					string message = 2;
				}
			You can use grpcrul to call the UnaryMethod method with the following command:

				grpcrul -p localhost:50051 ExampleService/UnaryMethod '{"id": 1, "name": "John Doe"}'
			grpcrul also supports sending binary or json encoded messages, providing --json or --binary flag will switch the message encoding accordingly.
			grpcrul also supports several other options that you can use to customize the behavior of the tool, such as setting the message compression, and providing the path to the certificate and key files to use when connecting to the service.
			You can consult the grpcrul documentation for more information on the available options.
						
			--------------------------------------------------------------------------------------
62.Ders ->
			
63.Ders ->
64.Ders ->












